<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta name="360-site-verification" content="25801ebe32430d2890004839ea377da2" />
  <script data-ad-client="ca-pub-4303078477555566" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-muniao.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-muniao.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-muniao.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">
  <meta name="google-site-verification" content="epFgX0s_0RM3CdjwFcsewfXzPov2g8s9ZBOLyaIUH-o">
  <meta name="baidu-site-verification" content="btK4cBsWUficCOsR">

<link rel="stylesheet" href="/css/main.css">

<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Noto Serif SC:300,300italic,400,400italic,700,700italic|Noto Sans SC:300,300italic,400,400italic,700,700italic|Fira Code:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext">
<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"www.qtmuniao.com","root":"/","scheme":"Gemini","version":"7.8.0","exturl":true,"sidebar":{"position":"right","display":"post","padding":18,"offset":12,"onmobile":false,"Muse | Mist":300,"Pisces | Gemini":300,"width":300},"copycode":{"enable":true,"show_result":false,"style":"default"},"back2top":{"enable":true,"sidebar":true,"scrollpercent":true},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":true,"lazyload":false,"pangu":true,"comments":{"style":"tabs","active":"gitalk","storage":true,"lazyload":false,"nav":{"gitalk":{"order":-2}},"activeClass":"gitalk"},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":false,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="上一篇讲了待调度任务的组织形式，这一篇来继续挑软骨头啃：节点资源抽象和调度策略。 引子由于 Ray 支持对任务进行显式的资源约束，因此需要对所有节点的资源进行硬件无关的抽象，将所有资源归一化管理，以在逻辑层面对资源进行增删。当有节点加入，需要感知其资源总量大小；当有任务调度，需要寻找满足约束节点；当任务调度成功，可以获取剩余可用资源等等。 Ray 除了对标准资源如 CPU，GPU 的支持，还支持对">
<meta property="og:type" content="article">
<meta property="og:title" content="Ray 源码解析（二）：资源抽象和调度策略">
<meta property="og:url" content="https://www.qtmuniao.com/2019/08/10/ray-source-reading-2/index.html">
<meta property="og:site_name" content="木鸟杂记">
<meta property="og:description" content="上一篇讲了待调度任务的组织形式，这一篇来继续挑软骨头啃：节点资源抽象和调度策略。 引子由于 Ray 支持对任务进行显式的资源约束，因此需要对所有节点的资源进行硬件无关的抽象，将所有资源归一化管理，以在逻辑层面对资源进行增删。当有节点加入，需要感知其资源总量大小；当有任务调度，需要寻找满足约束节点；当任务调度成功，可以获取剩余可用资源等等。 Ray 除了对标准资源如 CPU，GPU 的支持，还支持对">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2019-08-10T10:36:04.000Z">
<meta property="article:modified_time" content="2024-09-12T15:12:39.500Z">
<meta property="article:author" content="木鸟杂记">
<meta property="article:tag" content="分布式系统">
<meta property="article:tag" content="Ray">
<meta property="article:tag" content="调度策略">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="https://www.qtmuniao.com/2019/08/10/ray-source-reading-2/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>Ray 源码解析（二）：资源抽象和调度策略 | 木鸟杂记</title>
  
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-101943025-1"></script>
    <script>
      if (CONFIG.hostname === location.hostname) {
        window.dataLayer = window.dataLayer || [];
        function gtag(){dataLayer.push(arguments);}
        gtag('js', new Date());
        gtag('config', 'UA-101943025-1');
      }
    </script>


  <script>
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?1fb8def00cacde7d41798806b1150188";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>




  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">木鸟杂记</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">分布式系统，数据库，存储</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-photos">

    <a href="/photos/" rel="section"><i class="fa fa-image fa-fw"></i>相册</a>

  </li>
        <li class="menu-item menu-item-sparks">

    <a href="/sparks/" rel="section"><i class="fa fa-spinner fa-fw"></i>短想法</a>

  </li>
        <li class="menu-item menu-item-ddia">

    <span class="exturl" data-url="aHR0cHM6Ly9kZGlhLnF0bXVuaWFvLmNvbS8="><i class="fa fa-book fa-fw"></i>DDIA</span>

  </li>
        <li class="menu-item menu-item-podcast">

    <a href="/podcast/" rel="section"><i class="fa fa-heart fa-fw"></i>播客和书</a>

  </li>
        <li class="menu-item menu-item-service">

    <a href="/service/" rel="section"><i class="fa fa-dollar-sign fa-fw"></i>付费服务</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="reading-progress-bar"></div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://www.qtmuniao.com/2019/08/10/ray-source-reading-2/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/img/logo.jpg">
      <meta itemprop="name" content="木鸟杂记">
      <meta itemprop="description" content="一个喜欢摄影的分布式程序员">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="木鸟杂记">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          Ray 源码解析（二）：资源抽象和调度策略
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-08-10 18:36:04" itemprop="dateCreated datePublished" datetime="2019-08-10T18:36:04+08:00">2019-08-10</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2024-09-12 23:12:39" itemprop="dateModified" datetime="2024-09-12T23:12:39+08:00">2024-09-12</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/" itemprop="url" rel="index"><span itemprop="name">源码阅读</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/Ray/" itemprop="url" rel="index"><span itemprop="name">Ray</span></a>
                </span>
            </span>

          
            <span class="post-meta-item" title="阅读次数" id="busuanzi_container_page_pv" style="display: none;">
              <span class="post-meta-item-icon">
                <i class="eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span id="busuanzi_value_page_pv"></span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <p>上一篇讲了待调度任务的组织形式，这一篇来继续挑软骨头啃：节点资源抽象和调度策略。</p>
<h2 id="引子"><a href="#引子" class="headerlink" title="引子"></a>引子</h2><p>由于 Ray 支持对任务进行<strong>显式的资源约束</strong>，因此需要对所有节点的资源进行硬件无关的抽象，将所有资源归一化管理，以在逻辑层面对资源进行增删。当有节点加入，需要感知其资源总量大小；当有任务调度，需要寻找满足约束节点；当任务调度成功，可以获取剩余可用资源等等。</p>
<p>Ray 除了对标准资源如 CPU，GPU 的支持，还支持对用户自定义 label 的资源的调度。用户在启动节点（<code>ray start --resources &lt;resources&gt;</code>）指定该节点具有<strong>某种类别的资源</strong>（比如说 memory，bandwidth，某种型号的 GPU 等等）的总量，在定义 remote 函数时指定任务使用多少该类别的资源，Ray 的调度器在调度该任务时，就会按照用户自定义的资源需求将其调度到特定的机器上去。这是一种<strong>用户代码和调度器交互的一种有趣设计</strong>。</p>
<p>对于调度策略，由于 Ray 是去中心化的调度，很容易存在不一致状态。最简单的在实践中反而是统计最优的——对于每个任务找到符合资源约束的节点，随机选择一个，将任务调度过去。</p>
<span id="more"></span>

<p><em>作者：木鸟杂记 <a href="https://www.qtmuniao.com/">https://www.qtmuniao.com</a>, 转载请注明出处</em></p>
<h2 id="调度资源抽象-SchedulingResources"><a href="#调度资源抽象-SchedulingResources" class="headerlink" title="调度资源抽象(SchedulingResources)"></a>调度资源抽象(SchedulingResources)</h2><p>最基本的四个类是 <code>FractionalResourceQuantity</code> 、 <code>ResourceSet</code> 、  <code>ResourceIds</code> 和 <code>ResourceIdSet</code>。各个类的特点概述一下：</p>
<ul>
<li><code>FractionalResourceQuantity</code>  定义了某种资源的<strong>量值</strong></li>
<li><code>ResourceSet</code> 是一组不同种类资源及其量值的<strong>集合</strong></li>
<li><code>ResourceIds</code> 对资源量按分数进行了标号——0, 1 … quantity-1 。</li>
<li><code>ResourceIdSet</code> 是一组标号后的资源的集合。</li>
</ul>
<p>前两者是在<strong>多少</strong>层面上对资源进行描述，后两者是在<strong>索引</strong>层面对资源进行解构。</p>
<p><strong>后两者是在前两者基础上的细化</strong>。他们都定义了<strong>单个量值</strong>和集合不同种类量值构成的<strong>集合量</strong>。</p>
<p>此外，很重要的一点是，在 <code>FractionalResourceQuantity</code> 名字中也有体现，Ray 支持<strong>小数量值</strong>，但是只支持纯小数量值。为什么会有这种设计呢？举个最简单的例子，GPU 很贵嘛，于是就想多个 Task 共用一个 GPU，以提高 GPU 的利用率。那么每个 Task 在定义 GPU 需求的时候，就可以写需要零点几个 GPU。在这种场景下，一点几个和二点几个的非纯小数值就没什么意思了，毕竟要么独占一个，要么与他人共享一个。</p>
<h3 id="资源量值（FractionalResourceQuantity）"><a href="#资源量值（FractionalResourceQuantity）" class="headerlink" title="资源量值（FractionalResourceQuantity）"></a>资源量值（FractionalResourceQuantity）</h3><p><code>FractionalResourceQuantity</code> 是对 double 的包装，表示 Ray 中对资源度量的<strong>量</strong>。但为了计算不损失精度，其内部实际实现为 64bit 的整型——<strong>实际值</strong>乘以 <code> kResourceConversionFactor = 10000</code> 取整。其目的很明显：</p>
<ol>
<li>对于 Ray 的资源使用场景下，四五位小数左右的精度就够了</li>
<li>在这个精度内提供精确的运算</li>
</ol>
<p>在此基础上重载了可度量的量的一些基本操作——加减运算和布尔运算。在 Ray 的场景下，只有节点加入（增加资源），判断是否可调度（比较资源）、调度任务（减小资源）等操作，因此乘除操作是不需要的。</p>
<p>当然也可以从另外一个角度来理解，或许更好理解一点，其内部表示将 <strong>量纲&#x2F;单位</strong> 从逻辑的 <code>1</code>，缩小为了 <code>1/kResourceConversionFactor</code> 。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">FractionalResourceQuantity</span> &#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="comment">// 默认构造函数：resource_quantity_ = 0</span></span><br><span class="line">  <span class="built_in">FractionalResourceQuantity</span>();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 基本构造函数：指定资源量</span></span><br><span class="line">  <span class="built_in">FractionalResourceQuantity</span>(<span class="type">double</span> resource_quantity);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/// 加减运算</span></span><br><span class="line">  <span class="type">const</span> FractionalResourceQuantity <span class="keyword">operator</span>+(<span class="type">const</span> FractionalResourceQuantity &amp;rhs) <span class="type">const</span>;</span><br><span class="line">  <span class="type">const</span> FractionalResourceQuantity <span class="keyword">operator</span>-(<span class="type">const</span> FractionalResourceQuantity &amp;rhs) <span class="type">const</span>;</span><br><span class="line">  <span class="type">void</span> <span class="keyword">operator</span>+=(<span class="type">const</span> FractionalResourceQuantity &amp;rhs);</span><br><span class="line">  <span class="type">void</span> <span class="keyword">operator</span>-=(<span class="type">const</span> FractionalResourceQuantity &amp;rhs);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/// 布尔运算</span></span><br><span class="line">  <span class="type">bool</span> <span class="keyword">operator</span>==(<span class="type">const</span> FractionalResourceQuantity &amp;rhs) <span class="type">const</span>;</span><br><span class="line">  <span class="type">bool</span> <span class="keyword">operator</span>!=(<span class="type">const</span> FractionalResourceQuantity &amp;rhs) <span class="type">const</span>;</span><br><span class="line">  <span class="type">bool</span> <span class="built_in">operator</span>&lt;(<span class="type">const</span> FractionalResourceQuantity &amp;rhs) <span class="type">const</span>;</span><br><span class="line">  <span class="type">bool</span> <span class="keyword">operator</span>&gt;(<span class="type">const</span> FractionalResourceQuantity &amp;rhs) <span class="type">const</span>;</span><br><span class="line">  <span class="type">bool</span> <span class="keyword">operator</span>&lt;=(<span class="type">const</span> FractionalResourceQuantity &amp;rhs) <span class="type">const</span>;</span><br><span class="line">  <span class="type">bool</span> <span class="keyword">operator</span>&gt;=(<span class="type">const</span> FractionalResourceQuantity &amp;rhs) <span class="type">const</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/// 浮点型的实际值</span></span><br><span class="line">  <span class="function"><span class="type">double</span> <span class="title">ToDouble</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  <span class="comment">// 以 1/kResourceConversionFactor 为单位的资源量大小</span></span><br><span class="line">  <span class="type">int64_t</span> resource_quantity_;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>这类运算实现的时候有个基本思想：尽量<strong>复用</strong>，即定义<strong>最小数量的正交操作</strong>，然后用这些操作来实现另外的操作。这样有两个好处：</p>
<ol>
<li>代码简洁，因为复用了。</li>
<li>改动方便，将来如果要改变实现只需改变最基本的操作实现。</li>
</ol>
<p>具体到本例子中的布尔操作集，首先定义<strong>等于和小于</strong>操作符作为基本操作集，然后以此实现其他几个操作符。后面 <code>ResourceSet</code> 中也有类似的思想：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 两个基本操作</span></span><br><span class="line"><span class="type">bool</span> FractionalResourceQuantity::<span class="keyword">operator</span>==(<span class="type">const</span> FractionalResourceQuantity &amp;rhs) <span class="type">const</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> resource_quantity_ == rhs.resource_quantity_;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> FractionalResourceQuantity::<span class="keyword">operator</span>&lt;(<span class="type">const</span> FractionalResourceQuantity &amp;rhs) <span class="type">const</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> resource_quantity_ &lt; rhs.resource_quantity_;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 以下调用基本操作完成定义</span></span><br><span class="line"><span class="type">bool</span> FractionalResourceQuantity::<span class="keyword">operator</span>!=(<span class="type">const</span> FractionalResourceQuantity &amp;rhs) <span class="type">const</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> !(*<span class="keyword">this</span> == rhs);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> FractionalResourceQuantity::<span class="keyword">operator</span>&gt;(<span class="type">const</span> FractionalResourceQuantity &amp;rhs) <span class="type">const</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> rhs &lt; *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> FractionalResourceQuantity::<span class="keyword">operator</span>&lt;=(<span class="type">const</span> FractionalResourceQuantity &amp;rhs) <span class="type">const</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> !(*<span class="keyword">this</span> &gt; rhs);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> FractionalResourceQuantity::<span class="keyword">operator</span>&gt;=(<span class="type">const</span> FractionalResourceQuantity &amp;rhs) <span class="type">const</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> !(*<span class="keyword">this</span> &lt; rhs);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="资源集合-ResourceSet"><a href="#资源集合-ResourceSet" class="headerlink" title="资源集合(ResourceSet)"></a>资源集合(ResourceSet)</h3><p><code>ResourceSet</code> 是一系列不同种类的资源及其量值的集合，实现上是对字典（<code>unordered_map</code>）包装。在物理意义上，一般用来表示一个节点的总资源量、已经使用的资源量、剩余可用的资源量等等。</p>
<p>基本操作包括对单个资源的增删，以及资源集合间的运算；详细见代码内注释。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ResourceSet</span> &#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">ResourceSet</span>();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 三个构造函数：</span></span><br><span class="line">  <span class="comment">// 根据一个字典或者一个键值对列表构建 label(string)-&gt;amount(FractionalResourceQuantity) 的字典。</span></span><br><span class="line">  <span class="built_in">ResourceSet</span>(</span><br><span class="line">      <span class="type">const</span> std::unordered_map&lt;std::string, FractionalResourceQuantity&gt; &amp;resource_map);</span><br><span class="line">  <span class="built_in">ResourceSet</span>(<span class="type">const</span> std::unordered_map&lt;std::string, <span class="type">double</span>&gt; &amp;resource_map);</span><br><span class="line">  <span class="built_in">ResourceSet</span>(<span class="type">const</span> std::vector&lt;std::string&gt; &amp;resource_labels,</span><br><span class="line">              <span class="type">const</span> std::vector&lt;<span class="type">double</span>&gt; resource_capacity);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 析构函数</span></span><br><span class="line">  ~<span class="built_in">ResourceSet</span>();</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 判断资源集合 A 是否为 B 的子集(A 中所有 label 的 amount 都不大于 B 中对应 label 的 amount)</span></span><br><span class="line">  <span class="comment">// 以该操作作为基本操作，可以实现接下来三个操作</span></span><br><span class="line">  <span class="function"><span class="type">bool</span> <span class="title">IsSubset</span><span class="params">(<span class="type">const</span> ResourceSet &amp;other)</span> <span class="type">const</span></span>;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 下面函数中，前两个函数的实现一毛一样</span></span><br><span class="line">  <span class="type">bool</span> <span class="keyword">operator</span>==(<span class="type">const</span> ResourceSet &amp;rhs) <span class="type">const</span>;</span><br><span class="line">  <span class="function"><span class="type">bool</span> <span class="title">IsEqual</span><span class="params">(<span class="type">const</span> ResourceSet &amp;other)</span> <span class="type">const</span></span>;</span><br><span class="line">  <span class="function"><span class="type">bool</span> <span class="title">IsSuperset</span><span class="params">(<span class="type">const</span> ResourceSet &amp;other)</span> <span class="type">const</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 类似于字典的一些增删改查操作，即对某个种类的资源数量进行增删改查</span></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">AddOrUpdateResource</span><span class="params">(<span class="type">const</span> std::string &amp;resource_name,</span></span></span><br><span class="line"><span class="params"><span class="function">                           <span class="type">const</span> FractionalResourceQuantity &amp;capacity)</span></span>;</span><br><span class="line">  <span class="function"><span class="type">bool</span> <span class="title">DeleteResource</span><span class="params">(<span class="type">const</span> std::string &amp;resource_name)</span></span>;</span><br><span class="line">  <span class="function">FractionalResourceQuantity <span class="title">GetResource</span><span class="params">(<span class="type">const</span> std::string &amp;resource_name)</span> <span class="type">const</span></span>;</span><br><span class="line">  <span class="function"><span class="type">bool</span> <span class="title">IsEmpty</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 两个集合间的加减运算。需要注意的是，在增加的时候有时候不能超过一个上界：比如节点的资源总量大小，于是有了</span></span><br><span class="line">  <span class="comment">// AddResourcesCapacityConstrained; 在减小的时候，资源量不能减小为负值，于是有了 </span></span><br><span class="line">  <span class="comment">// SubtractResourcesStrict。这是两个上下界保护的函数。</span></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">AddResourcesCapacityConstrained</span><span class="params">(<span class="type">const</span> ResourceSet &amp;other,</span></span></span><br><span class="line"><span class="params"><span class="function">                                       <span class="type">const</span> ResourceSet &amp;total_resources)</span></span>;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">AddResources</span><span class="params">(<span class="type">const</span> ResourceSet &amp;other)</span></span>;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">SubtractResources</span><span class="params">(<span class="type">const</span> ResourceSet &amp;other)</span></span>;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">SubtractResourcesStrict</span><span class="params">(<span class="type">const</span> ResourceSet &amp;other)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 由于所有节点必然存在 CPU，所有任务调度是也必然需要 CPU 资源，因此单独拿出来作为一个函数。</span></span><br><span class="line">  <span class="comment">// 其对应的 label name 为：kCPU_ResourceLabel = &quot;CPU&quot;</span></span><br><span class="line">  <span class="function"><span class="type">const</span> ResourceSet <span class="title">GetNumCpus</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 返回字典形式组织的资源列表和对应数量；一个是 double 形式表示，一个是 FractionalResourceQuantity</span></span><br><span class="line">  <span class="comment">// 形式表示</span></span><br><span class="line">  <span class="function"><span class="type">const</span> std::unordered_map&lt;std::string, <span class="type">double</span>&gt; <span class="title">GetResourceMap</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">  <span class="function"><span class="type">const</span> std::unordered_map&lt;std::string, FractionalResourceQuantity&gt;</span></span><br><span class="line"><span class="function">      &amp;<span class="title">GetResourceAmountMap</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">const</span> std::string <span class="title">ToString</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  <span class="comment">// 内部资源及其数量字典</span></span><br><span class="line">  std::unordered_map&lt;std::string, FractionalResourceQuantity&gt; resource_capacity_;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>集合间加减运算时，有两个额外的带上下界检查的函数。应该是为了避免小数不精确运算导致的后果？</p>
<h3 id="资源标号-ResourceIds"><a href="#资源标号-ResourceIds" class="headerlink" title="资源标号(ResourceIds)"></a>资源标号(ResourceIds)</h3><p><code>ResourceIds</code> 解决的问题是为某种资源打上标号，并且以某种方式拆分资源。</p>
<p>对于<strong>资源标号</strong>，即给系统所有资源打上一个逻辑 ID（0~n-1）。比如说 GPU 0, GPU 1 等等。以使用户代码能够对资源进行定位，从而要求某段代码具体使用某个资源。</p>
<p>对于<strong>资源拆分</strong>，Ray 要求 API （<code>ray.remote(label=amount)</code>）只能以两种形式使用资源：</p>
<ol>
<li>amount &gt;&#x3D; 1 且必须是整数。</li>
<li>amount &lt; 1，即是纯小数。</li>
</ol>
<p>对应到物理意义上，即要么<strong>独占</strong>一到多个整份资源，要么和其他人<strong>共享</strong>单份资源。前者的经典例子是 CPU，后者经典例子是 GPU。</p>
<p>在内部实现上，<code>ResourceIds</code> 维护了两个列表。一个列表是整整型列表（<code>vector&lt;int64_t&gt; whole_ids_</code>）代表所有的整数份资源的 ID 列表。一个列表是键值对列表（<code>vector&lt;pair&lt;int64_t, FractionalResourceQuantity&gt;&gt;</code>），代表所有小数份资源 ID 及其对应的剩余份数。值得一提的是，对于一个节点，初始来说应该都是整数份资源（除非有某种特殊用途，比如不想让集群用满该节点资源啦）。然后随着需要小数份资源的任务的调度，一部分资源被切分，实现上表现为从整份资源列表中拿出一个资源，切分后，分出去一块给任务，剩下的放到小数份资源列表中。因此，<strong>两个列表中不会有相同的 ID</strong>，因为每个 ID 都最多对应一整份资源。如果由于任务完成，导致某些小数份资源释放，使得小数份资源列表中的具有同样 ID，这样的资源在还回时候会被合并，如果等于1之后，就会被拿到整数份资源列表中。</p>
<p>在资源分配的时候有些小原则。比如说要求小数份资源，我们优先去小数份资源列表里去找符合要求的，不能满足要求的话再去整数份资源列表中拆。</p>
<p>拆分的另一个问题是，我们不能将属于两个 ID 的两个小数份资源（比如说标号0 的有 0.5 份，标号 1 的有 0.5份）合到一块分配给一个要求较大的资源任务（比如说一个要求 0.75 份资源的任务）。举个例子来说，有两个 GPU 还剩一半用量，你不能将他们合起来分配给一个要求 0.75 份 GPU的任务。</p>
<p>还有一个变量 <code>decrement_backlog_ </code>用来记录所有超额资源请求。等待其他人 <code>Release</code> 了，会优先满足这些请求。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ResourceIds</span> &#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">ResourceIds</span>();</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 通过给定份数的资源构建 ResourceIds。resource_quantity 要么是个整数，要么是纯小数</span></span><br><span class="line">  <span class="function"><span class="keyword">explicit</span> <span class="title">ResourceIds</span><span class="params">(<span class="type">double</span> resource_quantity)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 在内部实现上，整数份的资源列表用 vector&lt;int&gt; 来表示所有对应的 ID，每个具有一整份资源。</span></span><br><span class="line">  <span class="comment">// 对于小数份资源，使用一个 vector&lt;pair&gt; 来表示某个 ID 和其对应的资源量值</span></span><br><span class="line">  <span class="comment">// 因此有以下三个构造函数。</span></span><br><span class="line">  <span class="function"><span class="keyword">explicit</span> <span class="title">ResourceIds</span><span class="params">(<span class="type">const</span> std::vector&lt;<span class="type">int64_t</span>&gt; &amp;whole_ids)</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">explicit</span> <span class="title">ResourceIds</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">      <span class="type">const</span> std::vector&lt;std::pair&lt;<span class="type">int64_t</span>, FractionalResourceQuantity&gt;&gt; &amp;fractional_ids)</span></span>;</span><br><span class="line">  <span class="built_in">ResourceIds</span>(</span><br><span class="line">      <span class="type">const</span> std::vector&lt;<span class="type">int64_t</span>&gt; &amp;whole_ids,</span><br><span class="line">      <span class="type">const</span> std::vector&lt;std::pair&lt;<span class="type">int64_t</span>, FractionalResourceQuantity&gt;&gt; &amp;fractional_ids);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 看是否有足够的要求的 resource_quantity 份资源。如果 resource_quantity 是整数，则只需看所有</span></span><br><span class="line">  <span class="comment">// 整数份资源列表。需要注意的是如果 resource_quantity 是小数，那么必须要有单个 ID 的资源量大于</span></span><br><span class="line">  <span class="comment">// resource_quantity 才可以(或者有不小于一份的整数资源，或者有大于resource_quantity的小数）</span></span><br><span class="line">  <span class="comment">// 而不能将两个小数凑在一块去大于 resource_quantity。因为分属于两个资源 ID 的量不能合到一块</span></span><br><span class="line">  <span class="function"><span class="type">bool</span> <span class="title">Contains</span><span class="params">(<span class="type">const</span> FractionalResourceQuantity &amp;resource_quantity)</span> <span class="type">const</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 根据上面的原则切下来一块资源 或者 回收一块资源。</span></span><br><span class="line">  <span class="comment">// 分配资源时，适当地进行拆分</span></span><br><span class="line">  <span class="comment">// 回收资源时，适当地进行合并。</span></span><br><span class="line">  <span class="function">ResourceIds <span class="title">Acquire</span><span class="params">(<span class="type">const</span> FractionalResourceQuantity &amp;resource_quantity)</span></span>;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">Release</span><span class="params">(<span class="type">const</span> ResourceIds &amp;resource_ids)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 虽然语义不一样，但是和 Release 实现一样：将两个 resource_ids 加和</span></span><br><span class="line">  <span class="function">ResourceIds <span class="title">Plus</span><span class="params">(<span class="type">const</span> ResourceIds &amp;resource_ids)</span> <span class="type">const</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 获取整数份/小数份资源 ID 列表</span></span><br><span class="line">  <span class="function"><span class="type">const</span> std::vector&lt;<span class="type">int64_t</span>&gt; &amp;<span class="title">WholeIds</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">  <span class="type">const</span> std::vector&lt;std::pair&lt;<span class="type">int64_t</span>, FractionalResourceQuantity&gt;&gt; &amp;<span class="built_in">FractionalIds</span>()</span><br><span class="line">      <span class="type">const</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 看是不是该ID集合中没有任何资源</span></span><br><span class="line">  <span class="function"><span class="type">bool</span> <span class="title">TotalQuantityIsZero</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 所有资源加和以 FractionalResourceQuantity 形式返回</span></span><br><span class="line">  <span class="function">FractionalResourceQuantity <span class="title">TotalQuantity</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="function">std::string <span class="title">ToString</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 通过 IncreaseCapacity 和 DecreaseCapacity 更新到指定资源量；这个是为了满足用户对</span></span><br><span class="line">  <span class="comment">// 对自定义资源动态调整而做的。</span></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">UpdateCapacity</span><span class="params">(<span class="type">int64_t</span> new_capacity)</span></span>;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  <span class="comment">// 判断 resource_quantity 是不是一个整数</span></span><br><span class="line">  <span class="function"><span class="type">bool</span> <span class="title">IsWhole</span><span class="params">(<span class="type">double</span> resource_quantity)</span> <span class="type">const</span></span>;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">IncreaseCapacity</span><span class="params">(<span class="type">int64_t</span> increment_quantity)</span></span>;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">DecreaseCapacity</span><span class="params">(<span class="type">int64_t</span> decrement_quantity)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 两个列表</span></span><br><span class="line">  std::vector&lt;<span class="type">int64_t</span>&gt; whole_ids_;</span><br><span class="line">  std::vector&lt;std::pair&lt;<span class="type">int64_t</span>, FractionalResourceQuantity&gt;&gt; fractional_ids_;</span><br><span class="line">  <span class="comment">// 追踪总量，总量即用 FractionalResourceQuantity 表示，也说明了该类是 FractionalResourceQuantity </span></span><br><span class="line">  <span class="comment">// 的细化</span></span><br><span class="line">  FractionalResourceQuantity total_capacity_;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 暂时性记下超额资源请求</span></span><br><span class="line">  <span class="type">int64_t</span> decrement_backlog_;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h3 id="资源标号集合-ResourceIdSet"><a href="#资源标号集合-ResourceIdSet" class="headerlink" title="资源标号集合(ResourceIdSet)"></a>资源标号集合(ResourceIdSet)</h3><p><code>ResourceIdSet</code> 表示一组带标号的可用资源的集合。实现上用了一个字典  <code>unordered_map&lt;string, ResourceIds&gt; available_resources_</code> ，表示资源种类到其数量（标号过的）映射，并在其上定义了和 <code>ResourceIds</code> 差不多的接口。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ResourceIdSet</span> &#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="comment">// 各种构造函数，就是构建 unordered_map</span></span><br><span class="line">  <span class="built_in">ResourceIdSet</span>();</span><br><span class="line">  <span class="built_in">ResourceIdSet</span>(<span class="type">const</span> ResourceSet &amp;resource_set);</span><br><span class="line">  <span class="built_in">ResourceIdSet</span>(<span class="type">const</span> std::unordered_map&lt;std::string, ResourceIds&gt; &amp;available_resources);</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 是否包含，索要和放回。和 ResourceIds 对应操作语义相同，只不过有单类资源变为了一组总资源。</span></span><br><span class="line">  <span class="function"><span class="type">bool</span> <span class="title">Contains</span><span class="params">(<span class="type">const</span> ResourceSet &amp;resource_set)</span> <span class="type">const</span></span>;</span><br><span class="line">  <span class="function">ResourceIdSet <span class="title">Acquire</span><span class="params">(<span class="type">const</span> ResourceSet &amp;resource_set)</span></span>;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">Release</span><span class="params">(<span class="type">const</span> ResourceIdSet &amp;resource_id_set)</span></span>;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">ReleaseConstrained</span><span class="params">(<span class="type">const</span> ResourceIdSet &amp;resource_id_set,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">const</span> ResourceSet &amp;resources_total)</span></span>;</span><br><span class="line">  <span class="comment">// 与 Release 实现一样</span></span><br><span class="line">  <span class="function">ResourceIdSet <span class="title">Plus</span><span class="params">(<span class="type">const</span> ResourceIdSet &amp;resource_id_set)</span> <span class="type">const</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/// 对于某类资源数量的增删查</span></span><br><span class="line">  <span class="comment">// 给某类资源增加指定数量</span></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">AddOrUpdateResource</span><span class="params">(<span class="type">const</span> std::string &amp;resource_name, <span class="type">int64_t</span> capacity)</span></span>;</span><br><span class="line">  <span class="comment">// 删除某类资源</span></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">DeleteResource</span><span class="params">(<span class="type">const</span> std::string &amp;resource_name)</span></span>;</span><br><span class="line">  <span class="comment">// 清空所有资源</span></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">Clear</span><span class="params">()</span></span>;</span><br><span class="line">  <span class="comment">// 获取所有可用资源，就是返回内部的散列表</span></span><br><span class="line">  <span class="function"><span class="type">const</span> std::unordered_map&lt;std::string, ResourceIds&gt; &amp;<span class="title">AvailableResources</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// cpu 所有任务都得用，所以单独拿出来</span></span><br><span class="line">  <span class="function">ResourceIdSet <span class="title">GetCpuResources</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 将带标号的资源集合转变为只有数量描述的资源集合</span></span><br><span class="line">  <span class="function">ResourceSet <span class="title">ToResourceSet</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 打印和序列化</span></span><br><span class="line">  <span class="function">std::string <span class="title">ToString</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">  <span class="function">std::vector&lt;rpc::ResourceIdSetInfo&gt; <span class="title">ToProtobuf</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  <span class="comment">// 从资源种类到带标号的资源集合的映射</span></span><br><span class="line">  std::unordered_map&lt;std::string, ResourceIds&gt; available_resources_;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h3 id="调度资源类（SchedulingResource）"><a href="#调度资源类（SchedulingResource）" class="headerlink" title="调度资源类（SchedulingResource）"></a>调度资源类（SchedulingResource）</h3><p>该类是最终对外负责的类，记录了<strong>某个节点上</strong>所有可供调度或者使用中的资源信息（<code>resources_total_</code>），待使用的资源信息（<code>resources_load_</code>）以及剩余可用的资源（<code>resources_available_</code>）。上面三个字段皆为 <code>ResourceIdSet</code> 类型。</p>
<p>三者关系为：</p>
<ol>
<li><code>resources_total_ = resouces_used_by_running_tasks + resources_available_</code></li>
<li><code>resources_load_ is part of resources_available_</code></li>
</ol>
<p>第二个关系可能看起来比较奇怪，后面会详细讲。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">SchedulingResources</span> &#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="comment">// 默认构造函数和指定总量的构造函数</span></span><br><span class="line">  <span class="built_in">SchedulingResources</span>();</span><br><span class="line">  <span class="built_in">SchedulingResources</span>(<span class="type">const</span> ResourceSet &amp;total);</span><br><span class="line"></span><br><span class="line">  ~<span class="built_in">SchedulingResources</span>();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 总量，负载量和可用量的 getter</span></span><br><span class="line">  <span class="function"><span class="type">const</span> ResourceSet &amp;<span class="title">GetAvailableResources</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">  <span class="function"><span class="type">const</span> ResourceSet &amp;<span class="title">GetLoadResources</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">  <span class="function"><span class="type">const</span> ResourceSet &amp;<span class="title">GetTotalResources</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 负载量和可用量的 setter，总量在构造时确定</span></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">SetLoadResources</span><span class="params">(ResourceSet &amp;&amp;newset)</span></span>;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">SetAvailableResources</span><span class="params">(ResourceSet &amp;&amp;newset)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 获取或者释放一组资源：在可用资源量上做增删</span></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">Release</span><span class="params">(<span class="type">const</span> ResourceSet &amp;resources)</span></span>;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">Acquire</span><span class="params">(<span class="type">const</span> ResourceSet &amp;resources)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 动态调整节点资源总量：更新某种种类的资源总量 or 删除某种种类资源</span></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">UpdateResource</span><span class="params">(<span class="type">const</span> std::string &amp;resource_name, <span class="type">int64_t</span> capacity)</span></span>;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">DeleteResource</span><span class="params">(<span class="type">const</span> std::string &amp;resource_name)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="function">std::string <span class="title">DebugString</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  ResourceSet resources_total_;</span><br><span class="line">  ResourceSet resources_available_;</span><br><span class="line">  ResourceSet resources_load_;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>有意思的是，单从该源码来看， <code>Release</code>  和 <code>Require</code> 只对 <code>resources_available_</code> 进行了操作；而 <code>resources_load_</code> 只有整体 set 和 get 的操作，当然也可以通过 <code>GetLoadResources</code> 获取其引用后，直接对其进行加减。</p>
<p>结合其他源码思忖了一下，Ray 似乎想用 <code>resources_load_</code> 描述所有 <code>SchedulingQueue::ready_queue_</code> 需求总量，而非正在运行的任务的需求总量。正在运行的任务需求量应为 <code>resources_total_ - resources_available_</code>。也就是说 <strong><code>resources_load_</code> 是 <code>resources_available_</code> 的一部分，用来描述所有准备好的任务的资源需求总量</strong>。</p>
<p>作为一个典型的实现代表，贴一下 <code>UpdateResource</code> 的代码实现，该操作是对某类资源总量的更新；</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">SchedulingResources::UpdateResource</span><span class="params">(<span class="type">const</span> std::string &amp;resource_name,</span></span></span><br><span class="line"><span class="params"><span class="function">                                         <span class="type">int64_t</span> capacity)</span> </span>&#123;</span><br><span class="line">  <span class="type">const</span> FractionalResourceQuantity new_capacity = <span class="built_in">FractionalResourceQuantity</span>(capacity);</span><br><span class="line">  <span class="type">const</span> FractionalResourceQuantity &amp;current_capacity =</span><br><span class="line">      resources_total_.<span class="built_in">GetResource</span>(resource_name);</span><br><span class="line">  <span class="keyword">if</span> (current_capacity &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="comment">// 如果该类资源存在，则将其总容量以及可用量进行相应更新</span></span><br><span class="line">    <span class="type">const</span> FractionalResourceQuantity capacity_difference =</span><br><span class="line">        new_capacity - current_capacity;</span><br><span class="line">    <span class="type">const</span> FractionalResourceQuantity &amp;current_available_capacity =</span><br><span class="line">        resources_available_.<span class="built_in">GetResource</span>(resource_name);</span><br><span class="line">    FractionalResourceQuantity new_available_capacity =</span><br><span class="line">        current_available_capacity + capacity_difference;</span><br><span class="line">    <span class="keyword">if</span> (new_available_capacity &lt; <span class="number">0</span>) &#123;</span><br><span class="line">      new_available_capacity = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    resources_total_.<span class="built_in">AddOrUpdateResource</span>(resource_name, new_capacity);</span><br><span class="line">    resources_available_.<span class="built_in">AddOrUpdateResource</span>(resource_name, new_available_capacity);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 如果不存在，则直接添加</span></span><br><span class="line">    resources_total_.<span class="built_in">AddOrUpdateResource</span>(resource_name, new_capacity);</span><br><span class="line">    resources_available_.<span class="built_in">AddOrUpdateResource</span>(resource_name, new_capacity);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="调度策略（SchedulingPolicy）"><a href="#调度策略（SchedulingPolicy）" class="headerlink" title="调度策略（SchedulingPolicy）"></a>调度策略（SchedulingPolicy）</h2><p>前面提到，Ray 使用去中心化的调度策略，即每个节点独立的对自己所看到的任务进行调度。<code>SchedulingPolicy</code> 就是描述单个节点的调度策略的，它通过构造函数拿到上一篇文章中提到的 <code>SchedulingQueue</code> 引用 ，从而拿到本节点所有的任务，然后通过 GCS 获取一组节点的资源概况（本节点的通过配置加载，对于其他节点，在感知到其加入集群的时候，从 GCS 中拉取），以 <code>unordered_map&lt;ClientID, SchedulingResources&gt; &amp;cluster_resources</code> 表示。从而根据任务资源需求与节点资源存量的适配情况，进行调度决策。</p>
<p>此外，还有个 <code>SpillOver</code> 方法，其中 <code>Schedule</code> 方法是针对所有状态为   <code>TaskState::PLACEABLE</code> 的任务在<strong>一组节点</strong>中进行决策，所谓<strong>调度</strong>；<code>SpillOver</code> 方法是针对所有状态为 <code>TaskState::INFEASIBLE</code> 和 <code>TaskState::READY</code> 的任务在新加入的<strong>单个节点</strong>进行尝试，所谓挤出。只是后来随着本地资源也可以动态调整，也会在本地资源调整后使用此策略。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">SchedulingPolicy</span> &#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="comment">// 构造函数：拿到本节点所有任务的引用</span></span><br><span class="line">  <span class="built_in">SchedulingPolicy</span>(<span class="type">const</span> SchedulingQueue &amp;scheduling_queue);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 根据集群资源分布以及任务资源需求做调度决策，返回任务与其所调度到的节点的集合</span></span><br><span class="line">  <span class="function">std::unordered_map&lt;TaskID, ClientID&gt; <span class="title">Schedule</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">      std::unordered_map&lt;ClientID, SchedulingResources&gt; &amp;cluster_resources,</span></span></span><br><span class="line"><span class="params"><span class="function">      <span class="type">const</span> ClientID &amp;local_client_id)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 在感知到新节点加入或者本地资源动态调整之后，对原先不可放置的任务进行尝试，并且匀出</span></span><br><span class="line">  <span class="comment">// 至多一个 READY 的任务到新节点。</span></span><br><span class="line">  <span class="function">std::vector&lt;TaskID&gt; <span class="title">SpillOver</span><span class="params">(SchedulingResources &amp;remote_scheduling_resources)</span> <span class="type">const</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">virtual</span> ~<span class="built_in">SchedulingPolicy</span>();</span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  <span class="comment">// 任务队列的引用</span></span><br><span class="line">  <span class="type">const</span> SchedulingQueue &amp;scheduling_queue_;</span><br><span class="line">  <span class="comment">/// 一个随机种子</span></span><br><span class="line">  std::mt19937_64 gen_;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="Schedule"><a href="#Schedule" class="headerlink" title="Schedule"></a>Schedule</h4><p>对于 <code>Schedule</code> 函数，大概伪码如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> task <span class="keyword">in</span> placeable_tasks_list:</span><br><span class="line">  clients = find_all_available_resources_statisfied_clients() <span class="comment"># available not include load</span></span><br><span class="line">  <span class="keyword">if</span> cliens.is_not_empty():</span><br><span class="line">    decision[task] = random_select_one(clients)</span><br><span class="line">  <span class="keyword">else</span>:</span><br><span class="line">    clients = find_all_total_resources_statisfied_clients() <span class="comment"># node whole resource</span></span><br><span class="line">    <span class="keyword">if</span> clients.is_not_empty():</span><br><span class="line">      decision[task] = random_select_one(clients)</span><br><span class="line"><span class="keyword">return</span> decision</span><br></pre></td></tr></table></figure>

<p>其中有两个值得注意的点：</p>
<ol>
<li>对于每个任务，会按次序对所有节点筛选两遍。第一次针对每个节点的 <strong>真正可用</strong> （<code>resources_available_ - resources_load_</code>）资源，第二次是针对节点所有资源（<code>resources_total</code>）。</li>
<li>虽然注释里写着TODO：<strong>按权重进行节点选择</strong>。但是注释过去一年多了，现在代码中的策略仍然是对满足资源要求的节点集合随机选择一个节点，将任务调度过去。我猜其中有个可能的原因是在去中心化的调度决策下，一致性很难保证，随机选择反而能取得更好的性能。举个例子，如果按<strong>空闲资源量作为权重</strong>进行节点选择，如果某个节点加入了，那么剩余节点在调度的时候可能一哄而上的将任务调度到该节点上，造成新加入的很快过载，然后该节点再将过载的任务调度出去，从而来回<strong>拉风车</strong>式调度。</li>
</ol>
<p>其中对于资源增删的操作稍稍复杂一些，贴在这里：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span> &amp;t : scheduling_queue_.<span class="built_in">GetTasks</span>(TaskState::PLACEABLE)) &#123;</span><br><span class="line">    <span class="type">const</span> <span class="keyword">auto</span> &amp;spec = t.<span class="built_in">GetTaskSpecification</span>();</span><br><span class="line">    <span class="type">const</span> <span class="keyword">auto</span> &amp;resource_demand = spec.<span class="built_in">GetRequiredPlacementResources</span>();</span><br><span class="line">    <span class="type">const</span> TaskID &amp;task_id = spec.<span class="built_in">TaskId</span>();</span><br><span class="line"></span><br><span class="line">    std::vector&lt;ClientID&gt; client_keys;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span> &amp;client_resource_pair : cluster_resources) &#123;</span><br><span class="line">      ClientID node_client_id = client_resource_pair.first;</span><br><span class="line">      <span class="type">const</span> <span class="keyword">auto</span> &amp;node_resources = client_resource_pair.second;</span><br><span class="line">      ResourceSet available_node_resources = <span class="built_in">ResourceSet</span>(node_resources.<span class="built_in">GetAvailableResources</span>());</span><br><span class="line">      <span class="comment">// 1. 获取节点真正可用资源（resources_available_ - resources_load_）。</span></span><br><span class="line">      available_node_resources.<span class="built_in">SubtractResources</span>(node_resources.<span class="built_in">GetLoadResources</span>());</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 检测资源约束</span></span><br><span class="line">      <span class="keyword">if</span> (resource_demand.<span class="built_in">IsSubset</span>(available_node_resources)) &#123;</span><br><span class="line">        client_keys.<span class="built_in">push_back</span>(node_client_id);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!client_keys.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">      <span class="comment">// 随机选一个 index</span></span><br><span class="line">      <span class="function">std::uniform_int_distribution&lt;<span class="type">int</span>&gt; <span class="title">distribution</span><span class="params">(<span class="number">0</span>, client_keys.size() - <span class="number">1</span>)</span></span>;</span><br><span class="line">      <span class="type">int</span> client_key_index = <span class="built_in">distribution</span>(gen_);</span><br><span class="line">      <span class="type">const</span> ClientID &amp;dst_client_id = client_keys[client_key_index];</span><br><span class="line">      decision[task_id] = dst_client_id;</span><br><span class="line">      <span class="comment">// 2. 更新对应节点负载资源</span></span><br><span class="line">      <span class="function">ResourceSet <span class="title">new_load</span><span class="params">(cluster_resources[dst_client_id].GetLoadResources())</span></span>;</span><br><span class="line">      new_load.<span class="built_in">AddResources</span>(resource_demand);</span><br><span class="line">      cluster_resources[dst_client_id].<span class="built_in">SetLoadResources</span>(std::<span class="built_in">move</span>(new_load));</span><br><span class="line">    &#125;</span><br><span class="line">  ...</span><br></pre></td></tr></table></figure>



<h3 id="SpillOver"><a href="#SpillOver" class="headerlink" title="SpillOver"></a>SpillOver</h3><p>该函数比较简单，伪码如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">spill_over</span>(<span class="params">remote_scheduling_resources</span>):</span><br><span class="line">  decision = []</span><br><span class="line">  new_load = ResourceSet()</span><br><span class="line">  </span><br><span class="line">  <span class="comment"># 尝试原先不可放置的任务</span></span><br><span class="line">  <span class="keyword">for</span> task <span class="keyword">in</span> infeasible_task_list:</span><br><span class="line">    <span class="keyword">if</span> task.required_res.is_subset_of(remote_scheduling_resources):</span><br><span class="line">      decision.append(task.<span class="built_in">id</span>)</span><br><span class="line">      new_load.add(task.required_res)</span><br><span class="line">  </span><br><span class="line">  <span class="comment"># 匀出至多一个 ready 任务</span></span><br><span class="line">  <span class="keyword">for</span> task <span class="keyword">in</span> ready_task_list:</span><br><span class="line">    <span class="keyword">if</span> task.required_res.is_subset_of(remote_scheduling_resources):</span><br><span class="line">      decision.append(task.<span class="built_in">id</span>)</span><br><span class="line">      new_load.add(task.required_res)</span><br><span class="line">      <span class="keyword">break</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment"># 设置其节点资源负载</span></span><br><span class="line">  remote_scheduling_resources.set_load(new_load)</span><br><span class="line">  <span class="keyword">return</span> decision</span><br></pre></td></tr></table></figure>

<p>该函数<strong>开始时</strong>应对的场景是，当感知到一个新节点上线时，会检测本机的某些任务能不能被调度过去。包括<strong>不可放置的任务</strong>（该节点上线前没有满足该任务资源需求的节点）和<strong>至多一个</strong>准备好的任务，我猜测这么干是为了弥补随机调度的不足，当一个新节点上线时，<strong>其他所有节点都将自己的任务匀给它一个</strong>（这个策略也比较有意思哈），以使得负载相对缓慢的从其他节点转移到新加入的节点。</p>
<p>后来随着版本迭代，节点<strong>静态</strong>资源变成<strong>动态</strong>资源。如果一个节点在启动时，通过配置加载其拥有的资源总量，此后维持不变，是为<strong>静态</strong>；如果在运行时资源总量仍然可设置，则为<strong>动态</strong>。在这种设计下，如果本节点资源总量被重新设置，那么也可能会调用此函数，对不可放置任务进行再尝试。至于匀任务这个操作，在此情景下，其实没什么意义。</p>
<p>最后，不要忘记的是，需要给被调度的节点设置资源负载，进行”占坑”，以使得其他调度决策及时感知到到本次调度所带来的节点资源负载变化。</p>
<h2 id="名词解释"><a href="#名词解释" class="headerlink" title="名词解释"></a>名词解释</h2><ol>
<li>逻辑和实现：逻辑表示类对外的抽象；实现表示类在内部的实际组织。</li>
<li>resouce_label&#x2F;resource_name: 或者说资源名称，标记某一种类的资源的标记，比如 GPU，CPU，Memory 等等</li>
<li>ResourceId: 资源标号，给所有资源按照 0, 1, … , n-1 打上标记，以对某个资源进行索引。典型的如 GPU0, GPU1 ..</li>
<li>静态和动态资源：这是针对节点资源总量来说的，如果一个节点在启动时通过配置加载其拥有的资源总量，此后维持不变，是为<strong>静态</strong>；如果在运行时资源总量仍然可设置，则为<strong>动态</strong></li>
</ol>

         <HR style="border:3 double #607d8b" color=#607d8b SIZE=3>
<div>
<p>我是青藤木鸟，一个喜欢摄影、专注大规模数据系统的程序员，欢迎关注我的公众号：“<strong>木鸟杂记</strong>”，有更多的分布式系统、存储和数据库相关的文章，欢迎关注。
关注公众号后，回复“<strong>资料</strong>”可以获取我总结一份分布式数据库学习资料。
回复“<strong>优惠券</strong>”可以获取我的大规模数据系统付费专栏《<a href="https://xiaobot.net/p/system-thinking" target="_blank" rel="noopener">系统日知录</a>》的八折优惠券。</p>
<p>我们还有相关的分布式系统和数据库的群，可以添加我的微信号：qtmuniao，我拉你入群。加我时记得备注：“分布式系统群”。
另外，如果你不想加群，还有一个分布式系统和数据库的论坛（点<a target="_blank" rel="noopener" href="https://distsys.cn/">这里</a>），欢迎来玩耍。</p>
<p><img src="https://s2.loli.net/2021/12/08/Gus9ditcmZo3Ukw.jpg" alt="wx-distributed-system-s.jpg" class="medium-zoom-image"></p>
</div>
        <script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-4303078477555566"
     crossorigin="anonymous"></script>
<ins class="adsbygoogle"
     style="display:block; text-align:center;"
     data-ad-layout="in-article"
     data-ad-format="fluid"
     data-ad-client="ca-pub-4303078477555566"
     data-ad-slot="1270196241"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
    </div>

    
    
    
      
  <div class="popular-posts-header">不妨一读</div>
  <ul class="popular-posts">
    <li class="popular-posts-item">
      <div class="popular-posts-title"><a href="/2019/07/28/ray-source-reading-1/" rel="bookmark">Ray 源码解析（一）：任务的状态转移和组织形式</a></div>
    </li>
    <li class="popular-posts-item">
      <div class="popular-posts-title"><a href="/2019/04/06/ray/" rel="bookmark">继Spark之后，UC Berkeley 推出新一代AI计算引擎——Ray</a></div>
    </li>
    <li class="popular-posts-item">
      <div class="popular-posts-title"><a href="/2017/06/29/hadoop-0.1.0-code-debug/" rel="bookmark">Hadoop-0.1.0代码调试运行</a></div>
    </li>
    <li class="popular-posts-item">
      <div class="popular-posts-title"><a href="/2017/07/11/hadoop-source-DataNode/" rel="bookmark">Hadoop 源码阅读之DFS（二）：DataNode</a></div>
    </li>
    <li class="popular-posts-item">
      <div class="popular-posts-title"><a href="/2018/02/24/hadoop-map-reduce/" rel="bookmark">Hadoop源码阅读之MapReduce（一）：基本概念和接口</a></div>
    </li>
    <li class="popular-posts-item">
      <div class="popular-posts-title"><a href="/2017/07/02/hadoop-source-DFS/" rel="bookmark">Hadoop 源码阅读之DFS（一）：一些基本的类</a></div>
    </li>
  </ul>

        <div class="reward-container">
  <div></div>
  <button onclick="var qr = document.getElementById('qr'); qr.style.display = (qr.style.display === 'none') ? 'block' : 'none';">
    打赏
  </button>
  <div id="qr" style="display: none;">
      
      <div style="display: inline-block;">
        <img src="https://i.postimg.cc/5yGJWLQW/image.png" alt="木鸟杂记 微信支付">
        <p>微信支付</p>
      </div>

  </div>
</div>


      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/" rel="tag"># 分布式系统</a>
              <a href="/tags/Ray/" rel="tag"># Ray</a>
              <a href="/tags/%E8%B0%83%E5%BA%A6%E7%AD%96%E7%95%A5/" rel="tag"># 调度策略</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2019/07/28/ray-source-reading-1/" rel="prev" title="Ray 源码解析（一）：任务的状态转移和组织形式">
      <i class="fa fa-chevron-left"></i> Ray 源码解析（一）：任务的状态转移和组织形式
    </a></div>
      <div class="post-nav-item">
    <a href="/2019/10/16/hexo-theme-landscaping/" rel="next" title="Hexo Next 主题进阶设置">
      Hexo Next 主题进阶设置 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          
    <div class="comments" id="gitalk-container"></div>

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%BC%95%E5%AD%90"><span class="nav-number">1.</span> <span class="nav-text">引子</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%B0%83%E5%BA%A6%E8%B5%84%E6%BA%90%E6%8A%BD%E8%B1%A1-SchedulingResources"><span class="nav-number">2.</span> <span class="nav-text">调度资源抽象(SchedulingResources)</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%B5%84%E6%BA%90%E9%87%8F%E5%80%BC%EF%BC%88FractionalResourceQuantity%EF%BC%89"><span class="nav-number">2.1.</span> <span class="nav-text">资源量值（FractionalResourceQuantity）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%B5%84%E6%BA%90%E9%9B%86%E5%90%88-ResourceSet"><span class="nav-number">2.2.</span> <span class="nav-text">资源集合(ResourceSet)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%B5%84%E6%BA%90%E6%A0%87%E5%8F%B7-ResourceIds"><span class="nav-number">2.3.</span> <span class="nav-text">资源标号(ResourceIds)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%B5%84%E6%BA%90%E6%A0%87%E5%8F%B7%E9%9B%86%E5%90%88-ResourceIdSet"><span class="nav-number">2.4.</span> <span class="nav-text">资源标号集合(ResourceIdSet)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%B0%83%E5%BA%A6%E8%B5%84%E6%BA%90%E7%B1%BB%EF%BC%88SchedulingResource%EF%BC%89"><span class="nav-number">2.5.</span> <span class="nav-text">调度资源类（SchedulingResource）</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%B0%83%E5%BA%A6%E7%AD%96%E7%95%A5%EF%BC%88SchedulingPolicy%EF%BC%89"><span class="nav-number">3.</span> <span class="nav-text">调度策略（SchedulingPolicy）</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Schedule"><span class="nav-number">3.0.1.</span> <span class="nav-text">Schedule</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#SpillOver"><span class="nav-number">3.1.</span> <span class="nav-text">SpillOver</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%90%8D%E8%AF%8D%E8%A7%A3%E9%87%8A"><span class="nav-number">4.</span> <span class="nav-text">名词解释</span></a></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="木鸟杂记"
      src="/img/logo.jpg">
  <p class="site-author-name" itemprop="name">木鸟杂记</p>
  <div class="site-description" itemprop="description">一个喜欢摄影的分布式程序员</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">114</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">39</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
        <span class="site-state-item-count">186</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <span class="exturl" data-url="aHR0cHM6Ly93d3cuemhpaHUuY29tL3Blb3BsZS9xdG11bmlhbw==" title="知乎 → https:&#x2F;&#x2F;www.zhihu.com&#x2F;people&#x2F;qtmuniao"><i class="zhihu fa-fw"></i>知乎</span>
      </span>
      <span class="links-of-author-item">
        <span class="exturl" data-url="aHR0cHM6Ly9zcGFjZS5iaWxpYmlsaS5jb20vMzA5MzM4MTI=" title="B站 → https:&#x2F;&#x2F;space.bilibili.com&#x2F;30933812"><i class="bzhan fa-fw"></i>B站</span>
      </span>
      <span class="links-of-author-item">
        <span class="exturl" data-url="aHR0cHM6Ly9xdG11bmlhby50dWNob25nLmNvbS8=" title="图虫 → https:&#x2F;&#x2F;qtmuniao.tuchong.com&#x2F;"><i class="tuchong fa-fw"></i>图虫</span>
      </span>
  </div>


  <div class="links-of-blogroll motion-element">
    <div class="links-of-blogroll-title"><i class="link fa-fw"></i>
      friends
    </div>
    <ul class="links-of-blogroll-list">
        <li class="links-of-blogroll-item">
          <span class="exturl" data-url="aHR0cHM6Ly9sYWlrZTltLmNvbQ==" title="https:&#x2F;&#x2F;laike9m.com">laike9m</span>
        </li>
        <li class="links-of-blogroll-item">
          <span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNoYW5na3VuLmRlLw==" title="https:&#x2F;&#x2F;blog.changkun.de&#x2F;">Changkun Ou</span>
        </li>
        <li class="links-of-blogroll-item">
          <span class="exturl" data-url="aHR0cHM6Ly93d3cua2F3YWJhbmdnYS5jb20=" title="https:&#x2F;&#x2F;www.kawabangga.com">卡瓦邦噶！</span>
        </li>
        <li class="links-of-blogroll-item">
          <span class="exturl" data-url="aHR0cHM6Ly95YW5iaW4uYmxvZw==" title="https:&#x2F;&#x2F;yanbin.blog">隔叶黄莺</span>
        </li>
        <li class="links-of-blogroll-item">
          <span class="exturl" data-url="aHR0cHM6Ly9nZWVrdHV0dS5jb20=" title="https:&#x2F;&#x2F;geektutu.com">极客兔兔</span>
        </li>
        <li class="links-of-blogroll-item">
          <span class="exturl" data-url="aHR0cHM6Ly94aWFveW91NjYuY29t" title="https:&#x2F;&#x2F;xiaoyou66.com">小游网</span>
        </li>
        <li class="links-of-blogroll-item">
          <span class="exturl" data-url="aHR0cDovL2dhb2NlZ2VnZS5jb20vQmxvZw==" title="http:&#x2F;&#x2F;gaocegege.com&#x2F;Blog">高策</span>
        </li>
        <li class="links-of-blogroll-item">
          <span class="exturl" data-url="aHR0cHM6Ly9yMTJmLmNvbQ==" title="https:&#x2F;&#x2F;r12f.com">Soul Orbit</span>
        </li>
        <li class="links-of-blogroll-item">
          <span class="exturl" data-url="aHR0cHM6Ly90YW54aW55dS53b3Jr" title="https:&#x2F;&#x2F;tanxinyu.work">谭新宇</span>
        </li>
        <li class="links-of-blogroll-item">
          <span class="exturl" data-url="aHR0cHM6Ly9penVhbHpoeS5jbi8=" title="https:&#x2F;&#x2F;izualzhy.cn&#x2F;">Ying's Blog</span>
        </li>
        <li class="links-of-blogroll-item">
          <span class="exturl" data-url="aHR0cHM6Ly9taWFuYmFvZHVvLmNvbS9vL2F1dGhvci1hV3lVbTIwPQ==" title="https:&#x2F;&#x2F;mianbaoduo.com&#x2F;o&#x2F;author-aWyUm20&#x3D;">我的面包多</span>
        </li>
        <li class="links-of-blogroll-item">
          <span class="exturl" data-url="aHR0cHM6Ly93d3cudnVsdHIuY29tLz9yZWY9ODMyOTc0OC00Rg==" title="https:&#x2F;&#x2F;www.vultr.com&#x2F;?ref&#x3D;8329748-4F">vultr vps 注册送 $50</span>
        </li>
    </ul>
  </div>


      </div>

      <div class="site-overview-wrap">
        <div class="motion-element sidebar-ads">
<script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<!-- 侧边栏-1 -->
<ins class="adsbygoogle"
style="display:inline-block;width:280px;height:100px"
data-ad-client="ca-pub-4303078477555566"
data-ad-slot="4071023010"></ins>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
</div>
<div style="
    font-size: 0.3em;
    height: 20px;
    margin-top: -10px;
">轻点广告 请我喝杯茶</div>

      </div>
        <div class="back-to-top motion-element">
          <i class="fa fa-arrow-up"></i>
          <span>0%</span>
        </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 2017 – 
  <span itemprop="copyrightYear">2024</span>
  <span class="with-love">
    <i class="user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">木鸟杂记</span>
</div>
  <div class="powered-by">由 <span class="exturl theme-link" data-url="aHR0cHM6Ly9oZXhvLmlv">Hexo</span> & <span class="exturl theme-link" data-url="aHR0cHM6Ly90aGVtZS1uZXh0Lm9yZw==">NexT.Gemini</span> 强力驱动
  </div>

        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="//cdn.jsdelivr.net/npm/medium-zoom@1/dist/medium-zoom.min.js"></script>
  <script src="//cdn.jsdelivr.net/npm/pangu@4/dist/browser/pangu.min.js"></script>

<script src="/js/utils.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  
  <script>
    (function(){
      var canonicalURL, curProtocol;
      //Get the <link> tag
      var x=document.getElementsByTagName("link");
		//Find the last canonical URL
		if(x.length > 0){
			for (i=0;i<x.length;i++){
				if(x[i].rel.toLowerCase() == 'canonical' && x[i].href){
					canonicalURL=x[i].href;
				}
			}
		}
    //Get protocol
	    if (!canonicalURL){
	    	curProtocol = window.location.protocol.split(':')[0];
	    }
	    else{
	    	curProtocol = canonicalURL.split(':')[0];
	    }
      //Get current URL if the canonical URL does not exist
	    if (!canonicalURL) canonicalURL = window.location.href;
	    //Assign script content. Replace current URL with the canonical URL
      !function(){var e=/([http|https]:\/\/[a-zA-Z0-9\_\.]+\.baidu\.com)/gi,r=canonicalURL,t=document.referrer;if(!e.test(r)){var n=(String(curProtocol).toLowerCase() === 'https')?"https://sp0.baidu.com/9_Q4simg2RQJ8t7jm9iCKT-xh_/s.gif":"//api.share.baidu.com/s.gif";t?(n+="?r="+encodeURIComponent(document.referrer),r&&(n+="&l="+r)):r&&(n+="?l="+r);var i=new Image;i.src=n}}(window);})();
  </script>















  

  
  <script src="//cdn.jsdelivr.net/npm/quicklink@1/dist/quicklink.umd.js"></script>
  <script>
      window.addEventListener('load', () => {
      quicklink({
        timeout : 3000,
        priority: true,
        ignores : [uri => uri.includes('#'),uri => uri === 'https://www.qtmuniao.com/2019/08/10/ray-source-reading-2/',]
      });
      });
  </script>

<link rel="stylesheet" href="//cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.css">

<script>
NexT.utils.loadComments(document.querySelector('#gitalk-container'), () => {
  NexT.utils.getScript('//cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.js', () => {
    var gitalk = new Gitalk({
      clientID    : '96b4b5363c4817dc1f62',
      clientSecret: '9e46a83f9fda0c5d3aabaaa64b60c027763cb677',
      repo        : 'blog-comment',
      owner       : 'songpengwei',
      admin       : ['songpengwei'],
      id          : 'dc369df0ff912a923ef79c33ce98993e',
        language: '',
      distractionFreeMode: true
    });
    gitalk.render('gitalk-container');
  }, window.Gitalk);
});
</script>

</body>
</html>
