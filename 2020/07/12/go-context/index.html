<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta name="360-site-verification" content="25801ebe32430d2890004839ea377da2" />
  <script data-ad-client="ca-pub-4303078477555566" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-muniao.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-muniao.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-muniao.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">
  <meta name="google-site-verification" content="epFgX0s_0RM3CdjwFcsewfXzPov2g8s9ZBOLyaIUH-o">
  <meta name="baidu-site-verification" content="btK4cBsWUficCOsR">

<link rel="stylesheet" href="/css/main.css">

<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Noto Serif SC:300,300italic,400,400italic,700,700italic|Noto Sans SC:300,300italic,400,400italic,700,700italic|Fira Code:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext">
<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"www.qtmuniao.com","root":"/","scheme":"Gemini","version":"7.8.0","exturl":true,"sidebar":{"position":"right","display":"post","padding":18,"offset":12,"onmobile":false,"Muse | Mist":300,"Pisces | Gemini":300,"width":300},"copycode":{"enable":true,"show_result":false,"style":"default"},"back2top":{"enable":true,"sidebar":true,"scrollpercent":true},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":true,"lazyload":false,"pangu":true,"comments":{"style":"tabs","active":"gitalk","storage":true,"lazyload":false,"nav":{"gitalk":{"order":-2}},"activeClass":"gitalk"},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":false,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="概述Context 是 Go 中一个比较独特而常用的概念，用好了往往能事半功倍。但如果不知其然而滥用，则往往变成 “为赋新词强说愁”，轻则影响代码结构，重则埋下许多bug。 Golang  使用树形派生的方式构造 Context，通过在不同过程 [1] 中传递 deadline 和 cancel 信号，来管理处理某个任务所涉及到的一组 goroutine 的生命周期，防止 goroutine 泄">
<meta property="og:type" content="article">
<meta property="og:title" content="Golang 笔记（二）：Context 源码剖析">
<meta property="og:url" content="https://www.qtmuniao.com/2020/07/12/go-context/index.html">
<meta property="og:site_name" content="木鸟杂记">
<meta property="og:description" content="概述Context 是 Go 中一个比较独特而常用的概念，用好了往往能事半功倍。但如果不知其然而滥用，则往往变成 “为赋新词强说愁”，轻则影响代码结构，重则埋下许多bug。 Golang  使用树形派生的方式构造 Context，通过在不同过程 [1] 中传递 deadline 和 cancel 信号，来管理处理某个任务所涉及到的一组 goroutine 的生命周期，防止 goroutine 泄">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://i.loli.net/2020/07/25/Yjbq6ZSkEHQ3X1u.png">
<meta property="og:image" content="https://i.loli.net/2020/07/25/d5Slcasj1FAzItu.png">
<meta property="og:image" content="https://i.loli.net/2020/07/25/9s6qG8RUkCQWLlc.png">
<meta property="og:image" content="https://i.loli.net/2020/07/25/Yjbq6ZSkEHQ3X1u.png">
<meta property="og:image" content="https://i.loli.net/2021/03/30/utbeLDk2UTxdc8R.jpg">
<meta property="article:published_time" content="2020-07-12T09:25:16.000Z">
<meta property="article:modified_time" content="2023-07-31T06:26:06.283Z">
<meta property="article:author" content="木鸟杂记">
<meta property="article:tag" content="golang">
<meta property="article:tag" content="go">
<meta property="article:tag" content="context">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://i.loli.net/2020/07/25/Yjbq6ZSkEHQ3X1u.png">

<link rel="canonical" href="https://www.qtmuniao.com/2020/07/12/go-context/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>Golang 笔记（二）：Context 源码剖析 | 木鸟杂记</title>
  
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-101943025-1"></script>
    <script>
      if (CONFIG.hostname === location.hostname) {
        window.dataLayer = window.dataLayer || [];
        function gtag(){dataLayer.push(arguments);}
        gtag('js', new Date());
        gtag('config', 'UA-101943025-1');
      }
    </script>


  <script>
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?1fb8def00cacde7d41798806b1150188";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>




  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">木鸟杂记</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">分布式系统，数据库，存储</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
        <li class="menu-item menu-item-ddia">

    <span class="exturl" data-url="aHR0cHM6Ly9kZGlhLnF0bXVuaWFvLmNvbS8="><i class="fa fa-book fa-fw"></i>DDIA</span>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-photos">

    <a href="/photos/" rel="section"><i class="fa fa-image fa-fw"></i>相册</a>

  </li>
        <li class="menu-item menu-item-付费服务">

    <a href="/service/" rel="section"><i class="fa fa-dollar-sign fa-fw"></i>付费服务</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="reading-progress-bar"></div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://www.qtmuniao.com/2020/07/12/go-context/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/img/logo.jpg">
      <meta itemprop="name" content="木鸟杂记">
      <meta itemprop="description" content="一个喜欢摄影的分布式程序员">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="木鸟杂记">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          Golang 笔记（二）：Context 源码剖析
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-07-12 17:25:16" itemprop="dateCreated datePublished" datetime="2020-07-12T17:25:16+08:00">2020-07-12</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-07-31 14:26:06" itemprop="dateModified" datetime="2023-07-31T14:26:06+08:00">2023-07-31</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/" itemprop="url" rel="index"><span itemprop="name">编程语言</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Go/" itemprop="url" rel="index"><span itemprop="name">Go</span></a>
                </span>
            </span>

          
            <span class="post-meta-item" title="阅读次数" id="busuanzi_container_page_pv" style="display: none;">
              <span class="post-meta-item-icon">
                <i class="eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span id="busuanzi_value_page_pv"></span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <p><img src="https://i.loli.net/2020/07/25/Yjbq6ZSkEHQ3X1u.png" alt="go-context-tree-construction.png"></p>
<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>Context 是 Go 中一个比较独特而常用的概念，用好了往往能事半功倍。但如果不知其然而滥用，则往往变成 “为赋新词强说愁”，轻则影响代码结构，重则埋下许多bug。</p>
<p>Golang  使用树形派生的方式构造 Context，通过在不同过程 <em>[1]</em> 中传递 deadline 和 cancel 信号，来管理处理某个任务所涉及到的一组 goroutine 的生命周期，防止 goroutine 泄露。并且可以通过附加在 Context 上的 Value 来传递&#x2F;共享一些跨越整个请求间的数据。</p>
<p>Context 最常用来追踪 RPC&#x2F;HTTP 等耗时的、跨进程的 IO 请求的生命周期，从而让外层调用者可以主动地或者自动地取消该请求，进而告诉子过程回收用到的所有 goroutine 和相关资源。</p>
<p>Context 本质上是一种在 API 间树形嵌套调用时传递信号的机制。本文将从接口、派生、源码分析、使用等几个方面来逐一解析 Context。</p>
<span id="more"></span>

<p><em>作者：木鸟杂记 <a href="https://www.qtmuniao.com/2020/07/12/go-context/">https://www.qtmuniao.com/2020/07/12/go-context/</a>, 转载请注明出处</em></p>
<h2 id="Context-接口"><a href="#Context-接口" class="headerlink" title="Context 接口"></a>Context 接口</h2><p>Context 接口如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Context 用以在多 API 间传递 deadline、cancelation 信号和请求的键值对。</span></span><br><span class="line"><span class="comment">// Context 中的方法能够安全的被多个 goroutine 并发调用。</span></span><br><span class="line"><span class="keyword">type</span> Context <span class="keyword">interface</span> &#123;</span><br><span class="line">    <span class="comment">// Done 返回一个只读 channel，该 channel 在 Context 被取消或者超时时关闭</span></span><br><span class="line">    Done() &lt;-<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Err 返回 Context 结束时的出错信息</span></span><br><span class="line">    Err() <span class="type">error</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果 Context 被设置了超时，Deadline 将会返回超时时限。</span></span><br><span class="line">    Deadline() (deadline time.Time, ok <span class="type">bool</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Value 返回关联到相关 Key 上的值，或者 nil.</span></span><br><span class="line">    Value(key <span class="keyword">interface</span>&#123;&#125;) <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面是简略注释，接口详细信息可以访问 Context 的 <a target="_blank" rel="noopener" href="https://golang.org/pkg/context/">godoc</a>。</p>
<ul>
<li><p><code>Done()</code> 方法返回一个只读的 channel，当 Context 被主动取消或者超时自动取消时，该 Context 所有派生 Context 的 done channel 都被 close 。所有子过程通过该字段收到 close 信号后，应该立即中断执行、释放资源然后返回。</p>
</li>
<li><p><code>Err()</code> 在上述 channel 被 close 前会返回 nil，在被 close 后会返回该 Context 被关闭的信息，error 类型，只有两种，<em>被取消</em>或者<em>超时</em>：</p>
</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> Canceled = errors.New(<span class="string">&quot;context canceled&quot;</span>)</span><br><span class="line"><span class="keyword">var</span> DeadlineExceeded <span class="type">error</span> = deadlineExceededError&#123;&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p><code>Deadline()</code> 如果本 Context 被设置了时限，则该函数返回 <code>ok=true</code> 和对应的到期时间点。否则，返回 <code>ok=false</code>和 nil。</p>
</li>
<li><p><code>Value()</code> 返回绑定在该 Context 链（我称为回溯链，下文会展开说明）上的给定的 Key 的值，如果没有，则返回 nil。注意，不要用于在函数中传参，其本意在于共享一些横跨整个 Context 生命周期范围的值。Key 可以是任何可比较的类型。为了防止 Key 冲突，最好将 Key 的类型定义为非导出类型，然后为其定义访问器。看一个通过 Context 共享用户信息的例子：</p>
</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> user</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;context&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// User 是要存于 Context 中的 Value 类型.</span></span><br><span class="line"><span class="keyword">type</span> User <span class="keyword">struct</span> &#123;...&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// key 定义为了非导出类型，以避免和其他 package 中的 key 冲突</span></span><br><span class="line"><span class="keyword">type</span> key <span class="type">int</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// userKey 是 Context 中用来关联 user.User 的 key，是非导出变量</span></span><br><span class="line"><span class="comment">// 客户端需要用 user.NewContext 和 user.FromContext 构建包含</span></span><br><span class="line"><span class="comment">// user 的 Context 和从 Context 中提取相应 user </span></span><br><span class="line"><span class="keyword">var</span> userKey key</span><br><span class="line"></span><br><span class="line"><span class="comment">// NewContext 返回一个带有用户值 u 的 Context.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewContext</span><span class="params">(ctx context.Context, u *User)</span></span> context.Context &#123;</span><br><span class="line">  <span class="keyword">return</span> context.WithValue(ctx, userKey, u)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// FromContext 从 Context 中提取 user，如果有的话.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">FromContext</span><span class="params">(ctx context.Context)</span></span> (*User, <span class="type">bool</span>) &#123;</span><br><span class="line">  u, ok := ctx.Value(userKey).(*User)</span><br><span class="line">  <span class="keyword">return</span> u, ok</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Context-派生"><a href="#Context-派生" class="headerlink" title="Context 派生"></a>Context 派生</h2><p>Context 设计之妙在于可以从已有 Context 进行树形派生，以管理一组过程的生命周期。我们上面说了单个 Context 实例是不可变的，但可以通过 context 包提供的三种方法：<code>WithCancel</code> 、 <code>WithTimeout</code> 和 <code>WithValue</code> 来进行派生并附加一些属性（可取消、时限、键值），以构造一组树形组织的 Context。</p>
<p><img src="https://i.loli.net/2020/07/25/d5Slcasj1FAzItu.png" alt="go-context-tree.png"></p>
<p>当根 Context 结束时，所有由其派生出的 Context 也会被一并取消。也就是说，父 Context 的生命周期涵盖所有子 Context 的生命周期。</p>
<p><code>context.Background()</code> 通常用作根节点，它不会超时，不能被取消。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Background 返回一个空 Context。它不能被取消，没有时限，没有附加键值。Background 通常用在</span></span><br><span class="line"><span class="comment">// main函数、init 函数、test 入口，作为某个耗时过程的根 Context。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Background</span><span class="params">()</span></span> Context</span><br></pre></td></tr></table></figure>

<p><code>WithCancel</code> 和  <code>WithTimeout</code>  可以从父 Context 进行派生，返回受限于父 Context 生命周期的新 Context。</p>
<p>通过 <code>WithCancel</code> 从 <code>context.Background() </code>派生出的 Context 要注意在对应过程完结后及时 cancel，否则会造成 Context 泄露。</p>
<p>使用 <code>WithTimeout</code> 可以控制某个过程的处理时限。具体过程为，到点后， Context 发送信号到 Done Channel，子过程检测到 Context Done Channel <em>[2]</em> 中的信号，会立即退出。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// WithCancel 返回一份父 Context 的拷贝，和一个 cancel 函数。当父 Context 被关闭或者 </span></span><br><span class="line"><span class="comment">// 此 cancel 函数被调用时，该 Context 的 Done Channel 会立即被关闭.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">WithCancel</span><span class="params">(parent Context)</span></span> (ctx Context, cancel CancelFunc)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用 CancelFunc 取消对应 Context.</span></span><br><span class="line"><span class="keyword">type</span> CancelFunc <span class="function"><span class="keyword">func</span><span class="params">()</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// WithTimeout 返回一份父 Context 的拷贝，和一个 cancel 函数。当父 Context 被关闭、</span></span><br><span class="line"><span class="comment">// cancel 函数被调用或者设定时限到达时，该 Context 的 Done Channel 会立即关闭。在 cancel 函数</span></span><br><span class="line"><span class="comment">// 被调用时，如果其内部 timer 仍在运行，将会被停掉。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">WithTimeout</span><span class="params">(parent Context, timeout time.Duration)</span></span> (Context, CancelFunc)</span><br></pre></td></tr></table></figure>

<p><code>WithValue</code> 可以给 Context 附加上整个处理过程中的键值。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// WithValue 返回一个父 Context 的副本，并且附加上给定的键值对.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">WithValue</span><span class="params">(parent Context, key <span class="keyword">interface</span>&#123;&#125;, val <span class="keyword">interface</span>&#123;&#125;)</span></span> Context</span><br></pre></td></tr></table></figure>

<h2 id="Context-源码解析"><a href="#Context-源码解析" class="headerlink" title="Context 源码解析"></a>Context 源码解析</h2><p>Go context 使用嵌入类，以类似继承的方式组织几个 Context 类：<code>emptyCtx</code>、<code>valueCtx</code>、 <code>cancelCtx</code>、<code>timerCtx</code>。</p>
<p><img src="https://i.loli.net/2020/07/25/9s6qG8RUkCQWLlc.png" alt="go-context-implementation.png"></p>
<p>形象的来说，通过嵌入的方式，Go 对树形组织的 Context 体系中的每个 Context 节点都构造了一个指向父亲实例”指针”。从另一个角度来说，这是一种经典代码组织模式——<a target="_blank" rel="noopener" href="https://sourcemaking.com/design_patterns/composite">组合模式</a>，每一层只增量 or 覆盖实现自己所关注的功能，然后通过路由调用来复用已有的实现。</p>
<h3 id="空实现-emptyCtx"><a href="#空实现-emptyCtx" class="headerlink" title="空实现 emptyCtx"></a>空实现 emptyCtx</h3><p><code>emptyCtx</code> 实现了一个空的 <code>Context</code>，所有接口函数都是空实现。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> emptyCtx <span class="type">int</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(*emptyCtx)</span></span> Deadline() (deadline time.Time, ok <span class="type">bool</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(*emptyCtx)</span></span> Done() &lt;-<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125; &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">nil</span> <span class="comment">// 返回 nil，从语法上说是空实现，从语义上说是该 Context 永远不会被关闭。</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//... 其他的省略，类似都是满足语法要求的空函数体</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(e *emptyCtx)</span></span> String() <span class="type">string</span> &#123;</span><br><span class="line">  <span class="keyword">switch</span> e &#123;</span><br><span class="line">  <span class="keyword">case</span> background:</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;context.Background&quot;</span></span><br><span class="line">  <span class="keyword">case</span> todo:</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;context.TODO&quot;</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">&quot;unknown empty Context&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>context.Background()</code> 和 <code>context.TODO()</code> 返回的都是 <code>emptyCtx</code> 的实例。但其语义略有不同。前者做为 Context 树的根节点，后者通常在不知道用啥时用。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> (</span><br><span class="line">  background = <span class="built_in">new</span>(emptyCtx)</span><br><span class="line">  todo       = <span class="built_in">new</span>(emptyCtx)</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Background</span><span class="params">()</span></span> Context &#123;</span><br><span class="line">  <span class="keyword">return</span> background</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TODO</span><span class="params">()</span></span> Context &#123;</span><br><span class="line">  <span class="keyword">return</span> todo</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="附加单键值-valueCtx"><a href="#附加单键值-valueCtx" class="headerlink" title="附加单键值 valueCtx"></a>附加单键值 valueCtx</h3><p><code>valueCtx</code> 嵌入了一个 <code>Context</code> 接口以进行 Context 派生，并且附加了一个 KV 对。从 <code>context.WithValue</code> 函数可以看出，每附加一个键值对，都得套上一层新的 <code>valueCtx</code>。在使用 <code>Value(key interface)</code> 接口访问某 Key 时，会沿着 Context 树回溯链不断向上遍历所有 Context 直到 <code>emptyCtx</code>：</p>
<ol>
<li>如果遇到 <code>valueCtx</code> 实例，则比较其 key 和给定 key 是否相等</li>
<li>如果遇到其他 Context 实例，就直接向上转发。但这里有个特例，为了获取给定 Context 所有祖先节点中最近的<code>cancelCtx</code>，go 用了一个特殊的 key：<code>cancelCtxKey</code>，遇到该 key 时，cancelCtx 会返回自身。这个在 <code>cancelCtx</code> 实现中会提到。</li>
</ol>
<p>对于其他的接口调用（<code>Done</code>, <code>Err</code>, <code>Deadline</code>），会路由到嵌入的 <code>Context</code> 上去。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> valueCtx <span class="keyword">struct</span> &#123;</span><br><span class="line">  Context <span class="comment">// 嵌入，指向父 Context</span></span><br><span class="line">  key, val <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *valueCtx)</span></span> Value(key <span class="keyword">interface</span>&#123;&#125;) <span class="keyword">interface</span>&#123;&#125; &#123;</span><br><span class="line">  <span class="keyword">if</span> c.key == key &#123;</span><br><span class="line">    <span class="keyword">return</span> c.val</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> c.Context.Value(key)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">WithValue</span><span class="params">(parent Context, key, val <span class="keyword">interface</span>&#123;&#125;)</span></span> Context &#123;</span><br><span class="line">  <span class="keyword">if</span> key == <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="built_in">panic</span>(<span class="string">&quot;nil key&quot;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> !reflectlite.TypeOf(key).Comparable() &#123;</span><br><span class="line">    <span class="built_in">panic</span>(<span class="string">&quot;key is not comparable&quot;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> &amp;valueCtx&#123;parent, key, val&#125; <span class="comment">// 附加上 kv，并引用父 Context</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="可取消的-cancelCtx"><a href="#可取消的-cancelCtx" class="headerlink" title="可取消的 cancelCtx"></a>可取消的 cancelCtx</h3><p>context 包中核心实现在 <code>cancelCtx</code> 中，包括构造树形结构、进行级联取消。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> cancelCtx <span class="keyword">struct</span> &#123;</span><br><span class="line">  Context</span><br><span class="line"></span><br><span class="line">  mu       sync.Mutex            <span class="comment">// 保证下面三个字段的互斥访问</span></span><br><span class="line">  done     <span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;         <span class="comment">// 惰式初始化，被第一个 cancel() 调用所关闭</span></span><br><span class="line">  children <span class="keyword">map</span>[canceler]<span class="keyword">struct</span>&#123;&#125; <span class="comment">// 被第一个 cancel() 调用置 nil</span></span><br><span class="line">  err      <span class="type">error</span>                 <span class="comment">// 被第一个 cancel() 调用置非 nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *cancelCtx)</span></span> Value(key <span class="keyword">interface</span>&#123;&#125;) <span class="keyword">interface</span>&#123;&#125; &#123;</span><br><span class="line">  <span class="keyword">if</span> key == &amp;cancelCtxKey &#123; </span><br><span class="line">    <span class="keyword">return</span> c</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> c.Context.Value(key)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *cancelCtx)</span></span> Done() &lt;-<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125; &#123;</span><br><span class="line">  c.mu.Lock()</span><br><span class="line">  <span class="keyword">if</span> c.done == <span class="literal">nil</span> &#123;</span><br><span class="line">    c.done = <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span><br><span class="line">  &#125;</span><br><span class="line">  d := c.done</span><br><span class="line">  c.mu.Unlock()</span><br><span class="line">  <span class="keyword">return</span> d</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> <code>Value()</code> 函数的实现有点意思，遇到特殊 key：<code>cancelCtxKey</code> 时，会返回自身。这个其实是复用了 Value 函数的回溯逻辑，从而在 Context 树回溯链中遍历时，可以找到给定 Context 的第一个祖先 <code>cancelCtx</code> 实例。</p>
<p><code>children</code> 保存的是子树中所有路径向下走的第一个可以 cancel 的 Context (实现了 <code>canceler</code> 接口，比如 <code>cancelCtx</code> 或 <code>timerCtx</code> 节点)，可以参考后面的图来形象理解。</p>
<p>下面将逐一详细说明。</p>
<h4 id="回溯链"><a href="#回溯链" class="headerlink" title="回溯链"></a>回溯链</h4><p>回溯链是各个 context 包在实现时利用 go 语言嵌入（<em>embedding</em>）的特性来构造的，主要用于：</p>
<ol>
<li><code>Value()</code> 函数被调用时沿着回溯链向上查找匹配的键值对。</li>
<li>复用 <code>Value()</code> 的逻辑查找最近 <code>cancelCtx</code> 祖先，以构造 Context 树。</li>
</ol>
<p>在 <code>valueCtx</code>、<code>cancelCtx</code>、<code>timerCtx</code> 中只有 <code>cancelCtx</code> <strong>直接</strong>（<code>valueCtx</code> 和 <code>timerCtx</code> 都是通过嵌入实现，调用该方法会直接转发到 <code>cancelCtx</code> 或者 <code>emptyCtx</code> ）实现了非空  <code>Done()</code> 方法，因此 <code>done := parent.Done()</code> 会返回第一个祖先 <code>cancelCtx</code> 中的 done channel。但如果 Context 树中有第三方实现的 Context 接口的实例时，<code>parent.Done()</code> 就有可能返回其他 channel。</p>
<p>因此，如果 <code>p.done != done</code> ，说明在回溯链中遇到的第一个实现非空 <code>Done()</code> Context 是第三方 Context ，而非 <code>cancelCtx</code>。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// parentCancelCtx 返回 parent 的第一个祖先 cancelCtx 节点</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">parentCancelCtx</span><span class="params">(parent Context)</span></span> (*cancelCtx, <span class="type">bool</span>) &#123;</span><br><span class="line">  done := parent.Done() <span class="comment">// 调用回溯链中第一个实现了 Done() 的实例(第三方Context类/cancelCtx)</span></span><br><span class="line">  <span class="keyword">if</span> done == closedchan || done == <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">false</span></span><br><span class="line">  &#125;</span><br><span class="line">  p, ok := parent.Value(&amp;cancelCtxKey).(*cancelCtx) <span class="comment">// 回溯链中第一个 cancelCtx 实例</span></span><br><span class="line">  <span class="keyword">if</span> !ok &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">false</span></span><br><span class="line">  &#125;</span><br><span class="line">  p.mu.Lock()</span><br><span class="line">  ok = p.done == done</span><br><span class="line">  p.mu.Unlock()</span><br><span class="line">  <span class="keyword">if</span> !ok &#123; <span class="comment">// 说明回溯链中第一个实现 Done() 的实例不是 cancelCtx 的实例</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">false</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> p, <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="树构建"><a href="#树构建" class="headerlink" title="树构建"></a>树构建</h4><p>Context 树的构建是在调用 <code>context.WithCancel()</code> 调用时通过 <code>propagateCancel</code> 进行的。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">WithCancel</span><span class="params">(parent Context)</span></span> (ctx Context, cancel CancelFunc) &#123;</span><br><span class="line">  c := newCancelCtx(parent)</span><br><span class="line">  propagateCancel(parent, &amp;c)</span><br><span class="line">  <span class="keyword">return</span> &amp;c, <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123; c.cancel(<span class="literal">true</span>, Canceled) &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Context 树，本质上可以细化为 <code>canceler</code> （<code>*cancelCtx</code> 和 <code>*timerCtx</code>）树，因为在级联取消时只需找到子树中所有的 <code>canceler</code> ，因此在实现时只需在树中保存所有 <code>canceler</code> 的关系即可（跳过 <code>valueCtx</code>），简单且高效。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// A canceler is a context type that can be canceled directly. The</span></span><br><span class="line"><span class="comment">// implementations are *cancelCtx and *timerCtx.</span></span><br><span class="line"><span class="keyword">type</span> canceler <span class="keyword">interface</span> &#123;</span><br><span class="line">  cancel(removeFromParent <span class="type">bool</span>, err <span class="type">error</span>)</span><br><span class="line">  Done() &lt;-<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>具体实现为，沿着回溯链找到第一个实现了 <code>Done()</code> 方法的实例，</p>
<ol>
<li>如果为 <code>canceler</code> 的实例，则其必有 children 字段，并且实现了 cancel 方法（canceler），将该 context 放进 children 数组即可。此后，父 cancelCtx 在 cancel 时会递归遍历所有 children，逐一 cancel。</li>
<li>如果为非 <code>canceler</code> 的第三方 Context 实例，则我们不知其内部实现，因此只能为每个新加的子 Context 启动一个守护 goroutine，当 父 Context 取消时，取消该 Context。</li>
</ol>
<p>需要注意的是，由于 Context 可能会被多个 goroutine 并行访问，因此在更改类字段时，需要再一次检查父节点是否已经被取消，若父 Context 被取消，则立即取消子 Context 并退出。 </p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">propagateCancel</span><span class="params">(parent Context, child canceler)</span></span> &#123;</span><br><span class="line">  done := parent.Done()</span><br><span class="line">  <span class="keyword">if</span> done == <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="comment">// 父节点不可取消</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">select</span> &#123;</span><br><span class="line">  <span class="keyword">case</span> &lt;-done:</span><br><span class="line">    <span class="comment">// 父节点已经取消</span></span><br><span class="line">    child.cancel(<span class="literal">false</span>, parent.Err())</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">  <span class="keyword">default</span>:</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> p, ok := parentCancelCtx(parent); ok &#123; <span class="comment">// 找到一个 cancelCtx 实例</span></span><br><span class="line">    p.mu.Lock()</span><br><span class="line">    <span class="keyword">if</span> p.err != <span class="literal">nil</span> &#123;</span><br><span class="line">      <span class="comment">// 父节点已经被取消</span></span><br><span class="line">      child.cancel(<span class="literal">false</span>, p.err)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> p.children == <span class="literal">nil</span> &#123;</span><br><span class="line">        p.children = <span class="built_in">make</span>(<span class="keyword">map</span>[canceler]<span class="keyword">struct</span>&#123;&#125;) <span class="comment">// 惰式创建</span></span><br><span class="line">      &#125;</span><br><span class="line">      p.children[child] = <span class="keyword">struct</span>&#123;&#125;&#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    p.mu.Unlock()</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;                                <span class="comment">// 找到一个非 cancelCtx 实例</span></span><br><span class="line">    atomic.AddInt32(&amp;goroutines, +<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">      <span class="keyword">select</span> &#123;</span><br><span class="line">      <span class="keyword">case</span> &lt;-parent.Done():</span><br><span class="line">        child.cancel(<span class="literal">false</span>, parent.Err())</span><br><span class="line">      <span class="keyword">case</span> &lt;-child.Done(): </span><br><span class="line">      &#125;</span><br><span class="line">    &#125;()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>下面用一张图来解释下回溯链和树组织， <em>C0</em>  是 <code>emptyCtx</code>，通常由 <code>context.Background()</code> 得来，作为 Context 树的根节点。<em>C1</em>~<em>C4</em> 依次通过嵌入的方式从各自父节点派生而来。图中的虚线是由嵌入（<em>embedded</em>）而构成的回溯链，实线是由 <code>cancelCtx</code> children 数组而保存的父子关系。</p>
<p><code>parentCancelCtx(C2)</code> 和 <code>parentCancelCtx(C4)</code> 都为 <em>C1</em>，则 <em>C1</em> 的 children 数组中保存的为 <em>C2</em> 和 <em>C4</em>。构建了这两层关系后，就可以沿着回溯链向上查询 Value 值，包括找到第一个祖先 <code>cancelCtx</code>；也可以沿着 children 关系往下进行级联取消。</p>
<p><img src="https://i.loli.net/2020/07/25/Yjbq6ZSkEHQ3X1u.png" alt="go-context-tree-construction.png"></p>
<p>当然，图中所有 Context 都是针对 go 包中的系统 Context，没有画出有第三方 Context 的情况。而实际代码由于增加了对第三方 Context 的处理逻辑，稍微难懂一些。区分系统 Context 实现和用户自定义 Context 的关键点在于是否实现了 <code>canceler</code> 接口。</p>
<p>第三方 Context 实现了此接口就可以进行树形组织，并且在上游 <code>cancelCtx</code> 取消时，递归调用 children 的 cancel 进行级联取消。否则只能通过为每个第三方 Context 启动一个 goroutine 来监听上游取消事件，以对第三方 Context 进行取消了。</p>
<h4 id="级联取消"><a href="#级联取消" class="headerlink" title="级联取消"></a>级联取消</h4><p>下面是级联取消中的关键函数 <code>cancelCtx.cancel</code> 的实现。在本 <code>cancelCtx</code> 取消时，需要级联取消以该 <code>cancelCtx</code> 为根节点的 Context 树中的所有 Context，并将根 <code>cancelCtx</code> 从其从父节点中摘除，以让 GC 回收该 <code>cancelCtx</code> 子树所有节点的资源。</p>
<p> <code>cancelCtx.cancel</code> 是非导出函数，不能在 context 包外调用，因此持有 Context 的内层过程不能自己取消自己，须由返回的 <code>CancelFunc</code> （简单的包裹了<code>cancelCtx.cancel</code> ）来取消，其句柄一般为外层过程所持有。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *cancelCtx)</span></span> cancel(removeFromParent <span class="type">bool</span>, err <span class="type">error</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> err == <span class="literal">nil</span> &#123; <span class="comment">// 需要给定取消的理由，Canceled or DeadlineExceeded</span></span><br><span class="line">    <span class="built_in">panic</span>(<span class="string">&quot;context: internal error: missing cancel error&quot;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  c.mu.Lock()</span><br><span class="line">  <span class="keyword">if</span> c.err != <span class="literal">nil</span> &#123;</span><br><span class="line">    c.mu.Unlock()</span><br><span class="line">    <span class="keyword">return</span> <span class="comment">// 已经被其他 goroutine 取消</span></span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 记下错误，并关闭 done</span></span><br><span class="line">  c.err = err</span><br><span class="line">  <span class="keyword">if</span> c.done == <span class="literal">nil</span> &#123;</span><br><span class="line">    c.done = closedchan</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">close</span>(c.done)</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 级联取消</span></span><br><span class="line">  <span class="keyword">for</span> child := <span class="keyword">range</span> c.children &#123;</span><br><span class="line">    <span class="comment">// <span class="doctag">NOTE:</span> 持有父 Context 的同时获取了子 Context 的锁</span></span><br><span class="line">    child.cancel(<span class="literal">false</span>, err)</span><br><span class="line">  &#125;</span><br><span class="line">  c.children = <span class="literal">nil</span></span><br><span class="line">  c.mu.Unlock()</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 子树根需要摘除，子树中其他节点则不再需要</span></span><br><span class="line">  <span class="keyword">if</span> removeFromParent &#123;</span><br><span class="line">    removeChild(c.Context, c)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="timerCtx"><a href="#timerCtx" class="headerlink" title="timerCtx"></a>timerCtx</h3><p><code>timerCtx</code> 在嵌入 <code>cancelCtx</code> 的基础上增加了一个计时器 timer，根据用户设置的时限，到点取消。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> timerCtx <span class="keyword">struct</span> &#123;</span><br><span class="line">  cancelCtx</span><br><span class="line">  timer *time.Timer <span class="comment">// Under cancelCtx.mu</span></span><br><span class="line"></span><br><span class="line">  deadline time.Time</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *timerCtx)</span></span> Deadline() (deadline time.Time, ok <span class="type">bool</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> c.deadline, <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *timerCtx)</span></span> cancel(removeFromParent <span class="type">bool</span>, err <span class="type">error</span>) &#123;</span><br><span class="line">  <span class="comment">// 级联取消子树中所有 Context</span></span><br><span class="line">  c.cancelCtx.cancel(<span class="literal">false</span>, err)</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">if</span> removeFromParent &#123;</span><br><span class="line">    <span class="comment">// 单独调用以摘除此节点，因为是摘除 c，而非 c.cancelCtx</span></span><br><span class="line">    removeChild(c.cancelCtx.Context, c)</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 关闭计时器</span></span><br><span class="line">  c.mu.Lock()</span><br><span class="line">  <span class="keyword">if</span> c.timer != <span class="literal">nil</span> &#123;</span><br><span class="line">    c.timer.Stop()</span><br><span class="line">    c.timer = <span class="literal">nil</span></span><br><span class="line">  &#125;</span><br><span class="line">  c.mu.Unlock()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>设置超时取消是在 <code>context.WithDeadline()</code> 中完成的。如果祖先节点时限早于本节点，只需返回一个 <code>cancelCtx</code> 即可，因为祖先节点到点后在级联取消时会将其取消。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">WithDeadline</span><span class="params">(parent Context, d time.Time)</span></span> (Context, CancelFunc) &#123;</span><br><span class="line">  <span class="keyword">if</span> cur, ok := parent.Deadline(); ok &amp;&amp; cur.Before(d) &#123;</span><br><span class="line">    <span class="comment">// 祖先节点的时限更早</span></span><br><span class="line">    <span class="keyword">return</span> WithCancel(parent)</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  c := &amp;timerCtx&#123;             </span><br><span class="line">    cancelCtx: newCancelCtx(parent), <span class="comment">// 使用一个新的 cancelCtx 实现部分 cancel 功能</span></span><br><span class="line">    deadline:  d,</span><br><span class="line">  &#125;</span><br><span class="line">  propagateCancel(parent, c) <span class="comment">// 构建 Context 取消树，注意传入的是 c 而非 c.cancelCtx</span></span><br><span class="line">  dur := time.Until(d)       <span class="comment">// 测试时限是否设的太近以至于已经结束了</span></span><br><span class="line">  <span class="keyword">if</span> dur &lt;= <span class="number">0</span> &#123;</span><br><span class="line">    c.cancel(<span class="literal">true</span>, DeadlineExceeded)</span><br><span class="line">    <span class="keyword">return</span> c, <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123; c.cancel(<span class="literal">false</span>, Canceled) &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 设置超时取消</span></span><br><span class="line">  c.mu.Lock()</span><br><span class="line">  <span class="keyword">defer</span> c.mu.Unlock()</span><br><span class="line">  <span class="keyword">if</span> c.err == <span class="literal">nil</span> &#123;</span><br><span class="line">    c.timer = time.AfterFunc(dur, <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">      c.cancel(<span class="literal">true</span>, DeadlineExceeded)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> c, <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123; c.cancel(<span class="literal">true</span>, Canceled) &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Context-使用"><a href="#Context-使用" class="headerlink" title="Context 使用"></a>Context 使用</h2><p>使用了 Context 的子过程<strong>须保证</strong>在 Context 被关闭时及时退出并释放资源。也就是说，使用 Context 需要遵循上述原则才能保证级联取消时释放资源的效果。因此，Context 本质上是一种树形分发信号的机制，可以用 Context 树追踪过程调用树，当外层过程取消时，使用 Context 级联通知所有被调用过程。</p>
<p>以下是一个典型子过程的检查 Context 以确定是否需要退出的代码片段：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> ; ; time.Sleep(time.Second) &#123;</span><br><span class="line">    <span class="keyword">select</span> &#123;</span><br><span class="line">    <span class="keyword">case</span> &lt;-context.Done():</span><br><span class="line">      <span class="keyword">return</span></span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 一些耗时操作</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看出，Context 接口本身并没有 Cancel 方法，这和 <code>Done()</code> 返回的 channel 是只读的是一个道理：Context 关闭信号的发送方和接收方通常不在一个函数中。比如，当父 goroutine 启动了一些子 goroutine 来干活时，只能是父 goroutine 来关闭 done channel，子 goroutine 来检测 channel 的关闭信号。即不能在子 goroutine 中 取消父 goroutine 中传递过来的 Context。</p>
<h2 id="Context-注意"><a href="#Context-注意" class="headerlink" title="Context 注意"></a>Context 注意</h2><p>Context 有一些使用实践需要遵循：</p>
<ol>
<li>Context 通常作为函数中第一个参数</li>
<li>不要在 struct 中存储 Context，每个函数都要显式的传递 Context。不过实践中可以根据 struct 的生命周期来灵活组合。</li>
<li>不要使用 nil Context，尽管语法上允许。不知道使用什么值合适时，可以使用 <code>context.TODO()</code> 。</li>
<li>Context value 是为了在请求生命周期中共享数据，而非作为函数中传递额外参数的方法。因为这是一种隐式的语义，极易造成 bug；要想传额外参数，还是要在函数中显式声明。</li>
<li>Context 是 immutable 的，因此是线程安全的，可以在多个 goroutine 中传递并使用同一个 Context。</li>
</ol>
<h2 id="注"><a href="#注" class="headerlink" title="注"></a>注</h2><p>[1] 文中的过程，指的是计算密集型或者 IO 密集型的耗时函数，或者 goroutine。</p>
<p>[2] Context 的 Done Channel，指的是 <code>context.Done()</code> 返回的 channel。它是 Context 内的关键数据结构，作为沟通不同过程的的渠道。需要结束时，父过程向该 channel 发送信号，子过程读取该 channel 信号后做扫尾工作并且退出。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol>
<li>go doc context：<a target="_blank" rel="noopener" href="https://golang.org/pkg/context/">https://golang.org/pkg/context/</a></li>
<li>code review conmments: <a target="_blank" rel="noopener" href="https://github.com/golang/go/wiki/CodeReviewComments#contexts">https://github.com/golang/go/wiki/CodeReviewComments#contexts</a></li>
<li>go blog context：<a target="_blank" rel="noopener" href="https://blog.golang.org/context">https://blog.golang.org/context</a></li>
<li>go context 源码：<a target="_blank" rel="noopener" href="https://golang.org/src/context/context.go?s=8419:8483#L222">https://golang.org/src/context/context.go?s=8419:8483#L222</a></li>
<li>go 语言设计与实现： <a target="_blank" rel="noopener" href="https://draveness.me/golang/docs/part3-runtime/ch06-concurrency/golang-context/">https://draveness.me/golang/docs/part3-runtime/ch06-concurrency/golang-context/</a></li>
</ol>
<hr>
<p><img src="https://i.loli.net/2021/03/30/utbeLDk2UTxdc8R.jpg" alt="wx-distributed-system-muniao-s.jpg"></p>

        <script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-4303078477555566"
     crossorigin="anonymous"></script>
<ins class="adsbygoogle"
     style="display:block; text-align:center;"
     data-ad-layout="in-article"
     data-ad-format="fluid"
     data-ad-client="ca-pub-4303078477555566"
     data-ad-slot="1270196241"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
    </div>

    
    
    
      
  <div class="popular-posts-header">不妨一读</div>
  <ul class="popular-posts">
    <li class="popular-posts-item">
      <div class="popular-posts-title"><a href="/2019/12/07/bazel-build-golang/" rel="bookmark">Bazel 构建 Golang 项目</a></div>
    </li>
    <li class="popular-posts-item">
      <div class="popular-posts-title"><a href="/2020/01/06/go-value-pointer-method/" rel="bookmark">Golang 笔记（一）：值方法和指针方法（Value Methods vs Pointer Methods）</a></div>
    </li>
    <li class="popular-posts-item">
      <div class="popular-posts-title"><a href="/2020/11/29/bolt-data-organised/" rel="bookmark">Boltdb 源码导读（一）：Boltdb 数据组织</a></div>
    </li>
    <li class="popular-posts-item">
      <div class="popular-posts-title"><a href="/2020/12/14/bolt-index-design/" rel="bookmark">Boltdb 源码导读（二）：Boltdb 索引设计</a></div>
    </li>
    <li class="popular-posts-item">
      <div class="popular-posts-title"><a href="/2021/01/09/go-slice/" rel="bookmark">Golang 笔记（三）：一种理解 Slice 的模型</a></div>
    </li>
    <li class="popular-posts-item">
      <div class="popular-posts-title"><a href="/2021/04/02/bolt-transaction/" rel="bookmark">Boltdb 源码导读（三）：Boltdb 事务实现</a></div>
    </li>
  </ul>

        <div class="reward-container">
  <div></div>
  <button onclick="var qr = document.getElementById('qr'); qr.style.display = (qr.style.display === 'none') ? 'block' : 'none';">
    打赏
  </button>
  <div id="qr" style="display: none;">
      
      <div style="display: inline-block;">
        <img src="https://i.postimg.cc/5yGJWLQW/image.png" alt="木鸟杂记 微信支付">
        <p>微信支付</p>
      </div>

  </div>
</div>


      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/golang/" rel="tag"># golang</a>
              <a href="/tags/go/" rel="tag"># go</a>
              <a href="/tags/context/" rel="tag"># context</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2020/07/03/leveldb-data-structures-skip-list/" rel="prev" title="漫谈 LevelDB 数据结构（一）：跳表（Skip List）">
      <i class="fa fa-chevron-left"></i> 漫谈 LevelDB 数据结构（一）：跳表（Skip List）
    </a></div>
      <div class="post-nav-item">
    <a href="/2020/11/18/leveldb-data-structures-bloom-filter/" rel="next" title="漫谈 LevelDB 数据结构（二）：布隆过滤器（Bloom Filter）">
      漫谈 LevelDB 数据结构（二）：布隆过滤器（Bloom Filter） <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          
    <div class="comments" id="gitalk-container"></div>

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%A6%82%E8%BF%B0"><span class="nav-number">1.</span> <span class="nav-text">概述</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Context-%E6%8E%A5%E5%8F%A3"><span class="nav-number">2.</span> <span class="nav-text">Context 接口</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Context-%E6%B4%BE%E7%94%9F"><span class="nav-number">3.</span> <span class="nav-text">Context 派生</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Context-%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90"><span class="nav-number">4.</span> <span class="nav-text">Context 源码解析</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%A9%BA%E5%AE%9E%E7%8E%B0-emptyCtx"><span class="nav-number">4.1.</span> <span class="nav-text">空实现 emptyCtx</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%99%84%E5%8A%A0%E5%8D%95%E9%94%AE%E5%80%BC-valueCtx"><span class="nav-number">4.2.</span> <span class="nav-text">附加单键值 valueCtx</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8F%AF%E5%8F%96%E6%B6%88%E7%9A%84-cancelCtx"><span class="nav-number">4.3.</span> <span class="nav-text">可取消的 cancelCtx</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%9B%9E%E6%BA%AF%E9%93%BE"><span class="nav-number">4.3.1.</span> <span class="nav-text">回溯链</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%A0%91%E6%9E%84%E5%BB%BA"><span class="nav-number">4.3.2.</span> <span class="nav-text">树构建</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%BA%A7%E8%81%94%E5%8F%96%E6%B6%88"><span class="nav-number">4.3.3.</span> <span class="nav-text">级联取消</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#timerCtx"><span class="nav-number">4.4.</span> <span class="nav-text">timerCtx</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Context-%E4%BD%BF%E7%94%A8"><span class="nav-number">5.</span> <span class="nav-text">Context 使用</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Context-%E6%B3%A8%E6%84%8F"><span class="nav-number">6.</span> <span class="nav-text">Context 注意</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%B3%A8"><span class="nav-number">7.</span> <span class="nav-text">注</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8F%82%E8%80%83"><span class="nav-number">8.</span> <span class="nav-text">参考</span></a></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="木鸟杂记"
      src="/img/logo.jpg">
  <p class="site-author-name" itemprop="name">木鸟杂记</p>
  <div class="site-description" itemprop="description">一个喜欢摄影的分布式程序员</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">95</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">33</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
        <span class="site-state-item-count">162</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <span class="exturl" data-url="aHR0cHM6Ly93d3cuemhpaHUuY29tL3Blb3BsZS9xdG11bmlhbw==" title="知乎 → https:&#x2F;&#x2F;www.zhihu.com&#x2F;people&#x2F;qtmuniao"><i class="zhihu fa-fw"></i>知乎</span>
      </span>
      <span class="links-of-author-item">
        <span class="exturl" data-url="aHR0cHM6Ly9zcGFjZS5iaWxpYmlsaS5jb20vMzA5MzM4MTI=" title="B站 → https:&#x2F;&#x2F;space.bilibili.com&#x2F;30933812"><i class="bzhan fa-fw"></i>B站</span>
      </span>
      <span class="links-of-author-item">
        <span class="exturl" data-url="aHR0cHM6Ly9xdG11bmlhby50dWNob25nLmNvbS8=" title="图虫 → https:&#x2F;&#x2F;qtmuniao.tuchong.com&#x2F;"><i class="tuchong fa-fw"></i>图虫</span>
      </span>
  </div>


  <div class="links-of-blogroll motion-element">
    <div class="links-of-blogroll-title"><i class="link fa-fw"></i>
      friends
    </div>
    <ul class="links-of-blogroll-list">
        <li class="links-of-blogroll-item">
          <span class="exturl" data-url="aHR0cHM6Ly9sYWlrZTltLmNvbQ==" title="https:&#x2F;&#x2F;laike9m.com">laike9m</span>
        </li>
        <li class="links-of-blogroll-item">
          <span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNoYW5na3VuLmRlLw==" title="https:&#x2F;&#x2F;blog.changkun.de&#x2F;">Changkun Ou</span>
        </li>
        <li class="links-of-blogroll-item">
          <span class="exturl" data-url="aHR0cHM6Ly93d3cua2F3YWJhbmdnYS5jb20=" title="https:&#x2F;&#x2F;www.kawabangga.com">卡瓦邦噶！</span>
        </li>
        <li class="links-of-blogroll-item">
          <span class="exturl" data-url="aHR0cHM6Ly95YW5iaW4uYmxvZw==" title="https:&#x2F;&#x2F;yanbin.blog">隔叶黄莺</span>
        </li>
        <li class="links-of-blogroll-item">
          <span class="exturl" data-url="aHR0cHM6Ly9nZWVrdHV0dS5jb20=" title="https:&#x2F;&#x2F;geektutu.com">极客兔兔</span>
        </li>
        <li class="links-of-blogroll-item">
          <span class="exturl" data-url="aHR0cHM6Ly94aWFveW91NjYuY29t" title="https:&#x2F;&#x2F;xiaoyou66.com">小游网</span>
        </li>
        <li class="links-of-blogroll-item">
          <span class="exturl" data-url="aHR0cDovL2dhb2NlZ2VnZS5jb20vQmxvZw==" title="http:&#x2F;&#x2F;gaocegege.com&#x2F;Blog">高策</span>
        </li>
        <li class="links-of-blogroll-item">
          <span class="exturl" data-url="aHR0cHM6Ly9yMTJmLmNvbQ==" title="https:&#x2F;&#x2F;r12f.com">Soul Orbit</span>
        </li>
        <li class="links-of-blogroll-item">
          <span class="exturl" data-url="aHR0cHM6Ly90YW54aW55dS53b3Jr" title="https:&#x2F;&#x2F;tanxinyu.work">谭新宇</span>
        </li>
        <li class="links-of-blogroll-item">
          <span class="exturl" data-url="aHR0cHM6Ly9penVhbHpoeS5jbi8=" title="https:&#x2F;&#x2F;izualzhy.cn&#x2F;">Ying's Blog</span>
        </li>
        <li class="links-of-blogroll-item">
          <span class="exturl" data-url="aHR0cHM6Ly9taWFuYmFvZHVvLmNvbS9vL2F1dGhvci1hV3lVbTIwPQ==" title="https:&#x2F;&#x2F;mianbaoduo.com&#x2F;o&#x2F;author-aWyUm20&#x3D;">我的面包多</span>
        </li>
        <li class="links-of-blogroll-item">
          <span class="exturl" data-url="aHR0cHM6Ly93d3cudnVsdHIuY29tLz9yZWY9ODMyOTc0OC00Rg==" title="https:&#x2F;&#x2F;www.vultr.com&#x2F;?ref&#x3D;8329748-4F">vultr vps 注册送 $50</span>
        </li>
    </ul>
  </div>


      </div>

      <div class="site-overview-wrap">
        <div class="motion-element sidebar-ads">
<script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<!-- 侧边栏-1 -->
<ins class="adsbygoogle"
style="display:inline-block;width:280px;height:100px"
data-ad-client="ca-pub-4303078477555566"
data-ad-slot="4071023010"></ins>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
</div>
<div style="
    font-size: 0.3em;
    height: 20px;
    margin-top: -10px;
">轻点广告 请我喝杯茶</div>

      </div>
        <div class="back-to-top motion-element">
          <i class="fa fa-arrow-up"></i>
          <span>0%</span>
        </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 2017 – 
  <span itemprop="copyrightYear">2023</span>
  <span class="with-love">
    <i class="user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">木鸟杂记</span>
</div>
  <div class="powered-by">由 <span class="exturl theme-link" data-url="aHR0cHM6Ly9oZXhvLmlv">Hexo</span> & <span class="exturl theme-link" data-url="aHR0cHM6Ly90aGVtZS1uZXh0Lm9yZw==">NexT.Gemini</span> 强力驱动
  </div>

        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="//cdn.jsdelivr.net/npm/medium-zoom@1/dist/medium-zoom.min.js"></script>
  <script src="//cdn.jsdelivr.net/npm/pangu@4/dist/browser/pangu.min.js"></script>

<script src="/js/utils.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  
  <script>
    (function(){
      var canonicalURL, curProtocol;
      //Get the <link> tag
      var x=document.getElementsByTagName("link");
		//Find the last canonical URL
		if(x.length > 0){
			for (i=0;i<x.length;i++){
				if(x[i].rel.toLowerCase() == 'canonical' && x[i].href){
					canonicalURL=x[i].href;
				}
			}
		}
    //Get protocol
	    if (!canonicalURL){
	    	curProtocol = window.location.protocol.split(':')[0];
	    }
	    else{
	    	curProtocol = canonicalURL.split(':')[0];
	    }
      //Get current URL if the canonical URL does not exist
	    if (!canonicalURL) canonicalURL = window.location.href;
	    //Assign script content. Replace current URL with the canonical URL
      !function(){var e=/([http|https]:\/\/[a-zA-Z0-9\_\.]+\.baidu\.com)/gi,r=canonicalURL,t=document.referrer;if(!e.test(r)){var n=(String(curProtocol).toLowerCase() === 'https')?"https://sp0.baidu.com/9_Q4simg2RQJ8t7jm9iCKT-xh_/s.gif":"//api.share.baidu.com/s.gif";t?(n+="?r="+encodeURIComponent(document.referrer),r&&(n+="&l="+r)):r&&(n+="?l="+r);var i=new Image;i.src=n}}(window);})();
  </script>















  

  
  <script src="//cdn.jsdelivr.net/npm/quicklink@1/dist/quicklink.umd.js"></script>
  <script>
      window.addEventListener('load', () => {
      quicklink({
        timeout : 3000,
        priority: true,
        ignores : [uri => uri.includes('#'),uri => uri === 'https://www.qtmuniao.com/2020/07/12/go-context/',]
      });
      });
  </script>

<link rel="stylesheet" href="//cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.css">

<script>
NexT.utils.loadComments(document.querySelector('#gitalk-container'), () => {
  NexT.utils.getScript('//cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.js', () => {
    var gitalk = new Gitalk({
      clientID    : '96b4b5363c4817dc1f62',
      clientSecret: '9e46a83f9fda0c5d3aabaaa64b60c027763cb677',
      repo        : 'blog-comment',
      owner       : 'songpengwei',
      admin       : ['songpengwei'],
      id          : '6ac17548b3be10a2cc51dfcf59bc6bd8',
        language: '',
      distractionFreeMode: true
    });
    gitalk.render('gitalk-container');
  }, window.Gitalk);
});
</script>

</body>
</html>
