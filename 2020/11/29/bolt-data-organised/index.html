<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta name="360-site-verification" content="25801ebe32430d2890004839ea377da2" />
  <script data-ad-client="ca-pub-4303078477555566" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-muniao.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-muniao.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-muniao.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">
  <meta name="google-site-verification" content="epFgX0s_0RM3CdjwFcsewfXzPov2g8s9ZBOLyaIUH-o">
  <meta name="baidu-site-verification" content="btK4cBsWUficCOsR">

<link rel="stylesheet" href="/css/main.css">

<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Noto Serif SC:300,300italic,400,400italic,700,700italic|Noto Sans SC:300,300italic,400,400italic,700,700italic|Fira Code:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext">
<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"www.qtmuniao.com","root":"/","scheme":"Gemini","version":"7.8.0","exturl":true,"sidebar":{"position":"right","display":"post","padding":18,"offset":12,"onmobile":false,"Muse | Mist":300,"Pisces | Gemini":300,"width":300},"copycode":{"enable":true,"show_result":false,"style":"default"},"back2top":{"enable":true,"sidebar":true,"scrollpercent":true},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":true,"lazyload":false,"pangu":true,"comments":{"style":"tabs","active":"gitalk","storage":true,"lazyload":false,"nav":{"gitalk":{"order":-2}},"activeClass":"gitalk"},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":false,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="boltdb 是市面上为数不多的纯 go 语言开发的、单机 KV 库。boltdb 基于  Howard Chu’s LMDB 项目 ，实现的比较清爽，去掉单元测试和适配代码，核心代码大概四千多行。简单的 API、简约的实现，也是作者的意图所在。由于作者精力所限，原 boltdb 已经封版，不再更新。若想改进，提交新的 pr，建议去 etcd 维护的 fork 版本 bbolt。 为了方便，本系">
<meta property="og:type" content="article">
<meta property="og:title" content="Boltdb 源码导读（一）：Boltdb 数据组织">
<meta property="og:url" content="https://www.qtmuniao.com/2020/11/29/bolt-data-organised/index.html">
<meta property="og:site_name" content="木鸟杂记">
<meta property="og:description" content="boltdb 是市面上为数不多的纯 go 语言开发的、单机 KV 库。boltdb 基于  Howard Chu’s LMDB 项目 ，实现的比较清爽，去掉单元测试和适配代码，核心代码大概四千多行。简单的 API、简约的实现，也是作者的意图所在。由于作者精力所限，原 boltdb 已经封版，不再更新。若想改进，提交新的 pr，建议去 etcd 维护的 fork 版本 bbolt。 为了方便，本系">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://i.loli.net/2020/11/29/scJkTp5GSdPlHW1.png">
<meta property="og:image" content="https://i.loli.net/2020/11/29/BjTF382uakiy4QA.png">
<meta property="og:image" content="https://i.loli.net/2020/11/29/d84eqFEGwiLQZUu.png">
<meta property="og:image" content="https://i.loli.net/2020/11/29/4eGQqLtk5fmNvH7.png">
<meta property="og:image" content="https://i.loli.net/2020/12/05/6SPHqWmLXkwiusj.png">
<meta property="og:image" content="https://i.loli.net/2021/03/30/utbeLDk2UTxdc8R.jpg">
<meta property="article:published_time" content="2020-11-29T03:54:52.000Z">
<meta property="article:modified_time" content="2023-07-31T06:26:06.283Z">
<meta property="article:author" content="木鸟杂记">
<meta property="article:tag" content="存储">
<meta property="article:tag" content="golang">
<meta property="article:tag" content="go">
<meta property="article:tag" content="boltdb">
<meta property="article:tag" content="kv engine">
<meta property="article:tag" content="源码阅读">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://i.loli.net/2020/11/29/scJkTp5GSdPlHW1.png">

<link rel="canonical" href="https://www.qtmuniao.com/2020/11/29/bolt-data-organised/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>Boltdb 源码导读（一）：Boltdb 数据组织 | 木鸟杂记</title>
  
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-101943025-1"></script>
    <script>
      if (CONFIG.hostname === location.hostname) {
        window.dataLayer = window.dataLayer || [];
        function gtag(){dataLayer.push(arguments);}
        gtag('js', new Date());
        gtag('config', 'UA-101943025-1');
      }
    </script>


  <script>
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?1fb8def00cacde7d41798806b1150188";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>




  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">木鸟杂记</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">分布式系统，数据库，存储</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
        <li class="menu-item menu-item-ddia">

    <span class="exturl" data-url="aHR0cHM6Ly9kZGlhLnF0bXVuaWFvLmNvbS8="><i class="fa fa-book fa-fw"></i>DDIA</span>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-photos">

    <a href="/photos/" rel="section"><i class="fa fa-image fa-fw"></i>相册</a>

  </li>
        <li class="menu-item menu-item-付费服务">

    <a href="/service/" rel="section"><i class="fa fa-dollar-sign fa-fw"></i>付费服务</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="reading-progress-bar"></div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://www.qtmuniao.com/2020/11/29/bolt-data-organised/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/img/logo.jpg">
      <meta itemprop="name" content="木鸟杂记">
      <meta itemprop="description" content="一个喜欢摄影的分布式程序员">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="木鸟杂记">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          Boltdb 源码导读（一）：Boltdb 数据组织
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-11-29 11:54:52" itemprop="dateCreated datePublished" datetime="2020-11-29T11:54:52+08:00">2020-11-29</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-07-31 14:26:06" itemprop="dateModified" datetime="2023-07-31T14:26:06+08:00">2023-07-31</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/" itemprop="url" rel="index"><span itemprop="name">源码阅读</span></a>
                </span>
            </span>

          
            <span class="post-meta-item" title="阅读次数" id="busuanzi_container_page_pv" style="display: none;">
              <span class="post-meta-item-icon">
                <i class="eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span id="busuanzi_value_page_pv"></span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <blockquote>
<p><a target="_blank" rel="noopener" href="https://github.com/boltdb/bolt">boltdb</a> 是市面上为数不多的纯 go 语言开发的、单机 KV 库。boltdb 基于  <a target="_blank" rel="noopener" href="https://twitter.com/hyc_symas">Howard Chu’s</a> <a target="_blank" rel="noopener" href="http://symas.com/mdb/">LMDB 项目</a> ，实现的比较清爽，去掉单元测试和适配代码，核心代码大概四千多行。简单的 API、简约的实现，也是作者的意图所在。由于作者精力所限，原 boltdb 已经封版，不再更新。若想改进，提交新的 pr，建议去 etcd 维护的 fork 版本 <a target="_blank" rel="noopener" href="https://github.com/etcd-io/bbolt">bbolt</a>。</p>
<p>为了方便，本系列导读文章仍以不再变动的原 repo 为基础。该项目麻雀虽小，五脏俱全，仅仅四千多行代码，就实现了一个基于 B+ 树索引、支持一写多读事务的单机 KV 引擎。代码本身简约朴实、注释得当，如果你是 go 语言爱好者、如果对 KV 库感兴趣，那 boltdb 绝对是不可错过的一个 repo。</p>
<p>本系列计划分成三篇文章，依次围绕<strong>数据组织</strong>、<strong>索引设计</strong>、<strong>事务实现</strong>等三个主要方面对 boltdb 源码进行剖析。由于三个方面不是完全正交解耦的，因此叙述时会不可避免的产生交织，读不懂时，暂时略过即可，待有全貌，再回来梳理。本文是第一篇， boltdb 数据组织。</p>
</blockquote>
<h2 id="引子"><a href="#引子" class="headerlink" title="引子"></a>引子</h2><p>一个存储引擎最底层的构成，就是处理数据在各种物理介质（比如在磁盘上、在内存里）上的组织。而这些数据组织也体现了该存储引擎在设计上的取舍哲学。</p>
<p>在文件系统上，boltdb 采用<strong>页</strong>（page）的组织方式，将一切数据都<strong>对齐</strong>到页；在内存中，boltdb 按 B+ 树组织数据，其基本单元是<strong>节点</strong>（node），一个内存中的树节点对应文件系统上一个或者多个<strong>连续的</strong>页。boltdb 就在数据组织上就只有这两种核心抽象，可谓设计简洁。当然，这种简洁必然是有代价的，后面文章会进行详细分析。</p>
<p>本文首先对节点和页的关系进行总体说明，然后逐一分析四种页的格式及其载入内存后的表示，最后按照 db 的生命周期串一下 db 文件的增长过程以及载入内存的策略。</p>
<span id="more"></span>

<p><em>作者：木鸟杂记 <a href="https://www.qtmuniao.com/2020/11/29/bolt-data-organised">https://www.qtmuniao.com/2020/11/29/bolt-data-organised</a>, 转载请注明出处</em></p>
<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>本文主要涉及到 page.go 和 freelist.go 两个源文件，主要分析了 boltdb 各种 page 在磁盘上的格式和其加载到内存中后的表示。</p>
<h3 id="顶层组织"><a href="#顶层组织" class="headerlink" title="顶层组织"></a>顶层组织</h3><p>boltdb 的数据组织，自上而下来说：</p>
<ol>
<li>每个 db 对应一个文件。</li>
<li>在逻辑上：<ul>
<li>一个 db 包含多个桶（bucket），n相当于多个命名空间（namespace），桶可以无限嵌套</li>
<li>每个桶对应一棵 B+ 树</li>
</ul>
</li>
<li>在物理上：<ul>
<li>一个 db 文件是按页为单位进行顺序存储</li>
<li>一个页大小和操作系统的页大小保持一致（通常是 4KB）</li>
</ul>
</li>
</ol>
<h3 id="页和节点"><a href="#页和节点" class="headerlink" title="页和节点"></a>页和节点</h3><p>页分为四种类型：</p>
<ul>
<li><strong>元信息页</strong>：全局有且仅有两个 meta 页，保存在文件；它们是 boltdb 实现事务的关键</li>
<li><strong>空闲列表页</strong>：有一种特殊的页，存放空闲页（freelist） id 列表；他们在文件中表现为一段一段的连续的页</li>
<li><strong>两种数据页</strong>：剩下的页都是数据页，有两种类型，分别对应 B+ 树中的分支节点和叶子节点</li>
</ul>
<p>页和节点的关系在于：</p>
<ol>
<li>页是 db 文件存储的基本单位，节点是 B+ 树的基本构成节点</li>
<li>一个数据节点对应一到多个<strong>连续的</strong>数据页</li>
<li>连续的<strong>数据页</strong>序列化加载到内存中就成为一个数据节点</li>
</ol>
<p>总结一下：在文件系统上线性组织的<strong>数据页</strong>，通过页内指针，在逻辑上组织成了一棵二维的 B+ 树，该树的树根保存在<strong>元信息</strong>页中，而文件中所有其他没有用到的页的 id 列表，保存在<strong>空闲列表页</strong>中。</p>
<h2 id="页格式和内存表示"><a href="#页格式和内存表示" class="headerlink" title="页格式和内存表示"></a>页格式和内存表示</h2><p>boltdb 中的页分四种类型：元信息页、空闲列表页、分支节点页和叶子节点页。boltdb 使用常量枚举标记：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> (</span><br><span class="line">  branchPageFlag   = <span class="number">0x01</span></span><br><span class="line">  leafPageFlag     = <span class="number">0x02</span></span><br><span class="line">  metaPageFlag     = <span class="number">0x04</span></span><br><span class="line">  freelistPageFlag = <span class="number">0x10</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>每个页都由定长 header 和数据部分组成：</p>
<p><img src="https://i.loli.net/2020/11/29/scJkTp5GSdPlHW1.png" alt="boltdb 页结构"></p>
<p>其中 ptr 指向的是页的数据部分，为了避免载入内存和写入文件系统时的序列化和反序列化操作，boltdb 使用了大量的 go unsafe 包中的指针操作。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> pgid <span class="type">uint64</span></span><br><span class="line"><span class="keyword">type</span> page <span class="keyword">struct</span> &#123;</span><br><span class="line">  id       pgid</span><br><span class="line">  flags    <span class="type">uint16</span>  <span class="comment">// 页类型，值为四种类型之一</span></span><br><span class="line">  count    <span class="type">uint16</span>  <span class="comment">// 对应的节点包含元素个数，比如说包含的 kv 对</span></span><br><span class="line">  overflow <span class="type">uint32</span>  <span class="comment">// 对应节点溢出页的个数，即使用 overflow+1 个页来保存对应节点</span></span><br><span class="line">  ptr      <span class="type">uintptr</span> <span class="comment">// 指向数据对应的 byte 数组，当 overlay&gt;0 时会跨越多个连续页；不过多个物理也在内存中也只会用一个 page 结构体来表示</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="元信息页（metaPage）"><a href="#元信息页（metaPage）" class="headerlink" title="元信息页（metaPage）"></a>元信息页（metaPage）</h3><p>boltdb 中有且仅有两个元信息页，保存在 db 文件的开头（pageid &#x3D; 0 和 1）。但是在元信息页中，ptr 指向的内容并非元素列表，而是整个 db 的元信息的各个字段。</p>
<p><img src="https://i.loli.net/2020/11/29/BjTF382uakiy4QA.png" alt="meta-page.png"></p>
<p>元信息页加载到内存后数据结构如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> meta <span class="keyword">struct</span> &#123;</span><br><span class="line">  magic    <span class="type">uint32</span></span><br><span class="line">  version  <span class="type">uint32</span></span><br><span class="line">  pageSize <span class="type">uint32</span> <span class="comment">// 该 db 页大小，通过 syscall.Getpagesize() 获取，通常为 4k</span></span><br><span class="line">  flags    <span class="type">uint32</span> <span class="comment">// </span></span><br><span class="line">  root     bucket <span class="comment">// 各个子 bucket 根所组成的树</span></span><br><span class="line">  freelist pgid   <span class="comment">// 空闲列表所存储的起始页 id</span></span><br><span class="line">  pgid     pgid   <span class="comment">// 当前用到的最大 page id，也即用到 page 的数量</span></span><br><span class="line">  txid     txid   <span class="comment">// 事务版本号，用以实现事务相关</span></span><br><span class="line">  checksum <span class="type">uint64</span> <span class="comment">// 校验和，用于校验 meta 页是否写完整</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="空闲列表页（freelistPage）"><a href="#空闲列表页（freelistPage）" class="headerlink" title="空闲列表页（freelistPage）"></a>空闲列表页（freelistPage）</h3><p>空闲列表页是 db 文件中一组连续的页（一个或者多个），用于保存在 db 使用过程中由于修改操作而释放的页的 id 列表。</p>
<p><img src="https://i.loli.net/2020/11/29/d84eqFEGwiLQZUu.png" alt="freelist-page.png"></p>
<p>在内存中表示时分为两部分，一部分是可以分配的空闲页列表 ids，另一部分是按事务 id 分别记录了在对应事务期间新增的空闲页列表。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 表示当前已经释放的 page 列表</span></span><br><span class="line"><span class="comment">// 和写事务刚释放的 page</span></span><br><span class="line"><span class="keyword">type</span> freelist <span class="keyword">struct</span> &#123;</span><br><span class="line">  ids        []pgid            <span class="comment">// all free and available free page ids.</span></span><br><span class="line">  pending    <span class="keyword">map</span>[txid][]pgid   <span class="comment">// mapping of soon-to-be free page ids by tx.</span></span><br><span class="line">  cache      <span class="keyword">map</span>[pgid]<span class="type">bool</span>     <span class="comment">// fast lookup of all free and pending page ids.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中 <code>pending</code> 部分需要单独记录主要是为了做 MVCC 的事务：</p>
<ol>
<li>写事务回滚时，对应事务待释放的空闲页列表要从 <code>pending</code> 项中删除。</li>
<li>某个写事务（比如 txid&#x3D;7）已经提交，但可能仍有一些读事务（如 txid &lt;&#x3D;7）仍然在使用其刚释放的页，因此不能立即用作分配。</li>
</ol>
<p>这部分内容会在 boltdb 事务中详细说明，这里只需有个印象即可。</p>
<h4 id="空闲列表转化为-page"><a href="#空闲列表转化为-page" class="headerlink" title="空闲列表转化为 page"></a>空闲列表转化为 page</h4><p>freelist 通过 <code>write</code> 函数，在<strong>事务提交时</strong>将自己写入给定的页，进行持久化。在写入时，会将 <code>pending</code> 和 <code>ids</code> 合并后写入，这是因为：</p>
<ol>
<li><code>write</code> 函数是在写事务提交时调用，写事务是串行的，因此 <code>pending</code> 中对应的写事务都已经提交。</li>
<li>写入文件是为了应对崩溃后重启，而重启时没有任何读操作，自然不用担心有读事务还在用刚释放的页。</li>
</ol>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(f *freelist)</span></span> write(p *page) <span class="type">error</span> &#123;</span><br><span class="line">  <span class="comment">// 设置页类型</span></span><br><span class="line">  p.flags |= freelistPageFlag</span><br><span class="line"></span><br><span class="line">  <span class="comment">// page.count 是 uint16 类型，其能表示的范围为 [0, 64k-1] 。如果空闲页 id 列表长度超出了此范围，就需要另想办法。</span></span><br><span class="line">  <span class="comment">// 这里用了个 trick，将 page.count 置为 64k 即 0xFFF，然后在数据部分的第一个元素存实际数量（以 pgid 为类型，即 uint64）。</span></span><br><span class="line">  lenids := f.count()</span><br><span class="line">  <span class="keyword">if</span> lenids == <span class="number">0</span> &#123;</span><br><span class="line">    p.count = <span class="type">uint16</span>(lenids)</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> lenids &lt; <span class="number">0xFFFF</span> &#123;</span><br><span class="line">    p.count = <span class="type">uint16</span>(lenids)</span><br><span class="line">    <span class="comment">// copyall 会将 pending 和 ids 合并并排序</span></span><br><span class="line">    f.copyall(((*[maxAllocSize]pgid)(unsafe.Pointer(&amp;p.ptr)))[:]) </span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    p.count = <span class="number">0xFFFF</span></span><br><span class="line">    ((*[maxAllocSize]pgid)(unsafe.Pointer(&amp;p.ptr)))[<span class="number">0</span>] = pgid(lenids)</span><br><span class="line">    f.copyall(((*[maxAllocSize]pgid)(unsafe.Pointer(&amp;p.ptr)))[<span class="number">1</span>:])</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>注意</strong>本步骤只是将 <code>freelist</code> 转化为内存中的页结构，需要额外的操作，比如 <code>tx.write()</code> 才会将对应的页真正持久化到文件。</p>
<h4 id="空闲列表从-page-中加载"><a href="#空闲列表从-page-中加载" class="headerlink" title="空闲列表从 page 中加载"></a>空闲列表从 page 中加载</h4><p>在数据库重启时，会首先从前两个元信息页恢复出一个合法的元信息。然后根据元信息中的 <code>freelist</code> 字段，找到存储 freelist 页的起始地址，进而将其恢复到内存中。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(f *freelist)</span></span> read(p *page) &#123;</span><br><span class="line">  <span class="comment">// count == 0xFFFF 表明实际 count 存储在 ptr 所指向的内容的第一个元素</span></span><br><span class="line">  idx, count := <span class="number">0</span>, <span class="type">int</span>(p.count)</span><br><span class="line">  <span class="keyword">if</span> count == <span class="number">0xFFFF</span> &#123;</span><br><span class="line">    idx = <span class="number">1</span></span><br><span class="line">    count = <span class="type">int</span>(((*[maxAllocSize]pgid)(unsafe.Pointer(&amp;p.ptr)))[<span class="number">0</span>])</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 将空闲列表从 page 拷贝内存中 freelist 结构体中</span></span><br><span class="line">  <span class="keyword">if</span> count == <span class="number">0</span> &#123;</span><br><span class="line">    f.ids = <span class="literal">nil</span></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    ids := ((*[maxAllocSize]pgid)(unsafe.Pointer(&amp;p.ptr)))[idx:count]</span><br><span class="line">    f.ids = <span class="built_in">make</span>([]pgid, <span class="built_in">len</span>(ids))</span><br><span class="line">    <span class="built_in">copy</span>(f.ids, ids)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 保证 ids 是有序的</span></span><br><span class="line">    sort.Sort(pgids(f.ids))</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 重新构建 freelist.cache 这个 map.</span></span><br><span class="line">  f.reindex()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="空闲列表分配"><a href="#空闲列表分配" class="headerlink" title="空闲列表分配"></a>空闲列表分配</h4><p>作者原版的空闲列表分配异常简单，<strong>分配单位</strong>是页，分配策略是**<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E9%A6%96%E6%AC%A1%E9%80%82%E5%BA%94%E7%AE%97%E6%B3%95/10147334">首次适应</a>**：即从排好序的空闲页列表 <code>ids</code> 中，找到第一段等于指定长度的连续空闲页，然后返回起始页 id。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 如果可以找到连续 n 个空闲页，则返回起始页 id</span></span><br><span class="line"><span class="comment">// 否则返回 0</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(f *freelist)</span></span> allocate(n <span class="type">int</span>) pgid &#123;</span><br><span class="line">  <span class="keyword">if</span> <span class="built_in">len</span>(f.ids) == <span class="number">0</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 遍历寻找连续空闲页，并判断是否等于 n</span></span><br><span class="line">  <span class="keyword">var</span> initial, previd pgid</span><br><span class="line">  <span class="keyword">for</span> i, id := <span class="keyword">range</span> f.ids &#123;</span><br><span class="line">    <span class="keyword">if</span> id &lt;= <span class="number">1</span> &#123;</span><br><span class="line">      <span class="built_in">panic</span>(fmt.Sprintf(<span class="string">&quot;invalid page allocation: %d&quot;</span>, id))</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果不连续，则重置 initial</span></span><br><span class="line">    <span class="keyword">if</span> previd == <span class="number">0</span> || id-previd != <span class="number">1</span> &#123;</span><br><span class="line">      initial = id</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (id-initial)+<span class="number">1</span> == pgid(n) &#123;</span><br><span class="line">      <span class="comment">// 当正好分配到 ids 中前 n 个 page 时，仅简单往前调整 f.ids 切片即可。</span></span><br><span class="line">      <span class="comment">// 尽管一时会造成空间浪费，但是在对 f.ids append/free 操作时，会按需</span></span><br><span class="line">      <span class="comment">// 重新空间分配，重新分配会导致这些浪费空间被回收掉</span></span><br><span class="line">      <span class="keyword">if</span> (i + <span class="number">1</span>) == n &#123;</span><br><span class="line">        f.ids = f.ids[i+<span class="number">1</span>:]</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">copy</span>(f.ids[i-n+<span class="number">1</span>:], f.ids[i+<span class="number">1</span>:])</span><br><span class="line">        f.ids = f.ids[:<span class="built_in">len</span>(f.ids)-n]</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 从 cache 中删除对应 page id</span></span><br><span class="line">      <span class="keyword">for</span> i := pgid(<span class="number">0</span>); i &lt; pgid(n); i++ &#123;</span><br><span class="line">        <span class="built_in">delete</span>(f.cache, initial+i)</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">return</span> initial</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    previd = id</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个 GC 策略相当简单直接，是线性的时间复杂度。阿里似乎做过一个 patch，将所有空闲 page 按其连续长度 group by 了一下。</p>
<h3 id="叶子节点页（leafPage）"><a href="#叶子节点页（leafPage）" class="headerlink" title="叶子节点页（leafPage）"></a>叶子节点页（leafPage）</h3><p>这种页对应 <strong>B+ 树</strong>中叶子节点，叶子节点包含的元素有两种类型：普通 KV 数据、subbucket。</p>
<p>对于前者来说，页中存储的基本元素为某个 bucket 中一条用户数据。对于后者来说，页中的一个元素为该 db 中的某个 subbucket 。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// page ptr 指向的字节数组中的单个元素</span></span><br><span class="line"><span class="keyword">type</span> leafPageElement <span class="keyword">struct</span> &#123; </span><br><span class="line">  flags         <span class="type">uint32</span>    <span class="comment">// 普通 kv （flags=0）还是 subbucket（flags=bucketLeafFlag）</span></span><br><span class="line">  pos           <span class="type">uint16</span>    <span class="comment">// kv header 与对应 kv 的距离</span></span><br><span class="line">  ksize         <span class="type">uint32</span>    <span class="comment">// key 的字节数</span></span><br><span class="line">  vsize         <span class="type">uint32</span>    <span class="comment">// val 字节数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其详细结构如下：</p>
<p><img src="https://i.loli.net/2020/11/29/4eGQqLtk5fmNvH7.png" alt="leaf-page-element.png"></p>
<p>可以看出，leaf page 在组织数据时，将<strong>元素头</strong>（<code>leafPageElement</code>）和<strong>元素本身</strong>（<code>key value</code>）分开存储。这样的好处在于 <code>leafPageElement</code> 是定长的，可以按下标访问对应元素。在二分查找指定 key 时，只需按需加载相应页到内存（访问 page 时是通过 mmap 进行的，因此只有访问时才会真正将数据从文件系统中加载到内存）即可。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">inodes := p.leafPageElements()</span><br><span class="line">index := sort.Search(<span class="type">int</span>(p.count), <span class="function"><span class="keyword">func</span><span class="params">(i <span class="type">int</span>)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> bytes.Compare(inodes[i].key(), key) != <span class="number">-1</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>如果元素头和对应元素紧邻存储，则需将 <code>leafPageElement</code> 数组对应的所有页顺序读取，全部加载到内存，才能进行二分。</p>
<p>另外一个小优化是 pos 存储的是元素头的起始地址到元素的起始地址的<strong>相对偏移量</strong>，而非以 <code>ptr</code> 指针为起始地址的<strong>绝对偏移量</strong>。这样可以用尽量少的位数（<code>pos</code> 是 <code>uint16</code>） 表示尽量长的距离。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(n *branchPageElement)</span></span> key() []<span class="type">byte</span> &#123;</span><br><span class="line">  buf := (*[maxAllocSize]<span class="type">byte</span>)(unsafe.Pointer(n)) <span class="comment">// buf 是元素头起始地址</span></span><br><span class="line">  <span class="keyword">return</span> (*[maxAllocSize]<span class="type">byte</span>)(unsafe.Pointer(&amp;buf[n.pos]))[:n.ksize]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="分支节点页（branchPage）"><a href="#分支节点页（branchPage）" class="headerlink" title="分支节点页（branchPage）"></a>分支节点页（branchPage）</h3><p>分支节点页和叶子节点页的结构大体相同。不同之处在于，页中保存的数据的 value 是 page id，即该分支节点在哪些 key 上的分支分别指向的 page 。</p>
<p><img src="https://i.loli.net/2020/12/05/6SPHqWmLXkwiusj.png" alt="branch-element.png"></p>
<p><code>branchPageElement</code> 中的 key 存的是其指向的页中的起始 key。</p>
<h2 id="转换流程"><a href="#转换流程" class="headerlink" title="转换流程"></a>转换流程</h2><p>boltdb 使用 mmap 将 db 文件映射到内存空间。在构建树并且访问过程中，按需将对应的页加载到内存里，并且利用操作系统的页缓存策略进行替换。</p>
<h3 id="文件增长"><a href="#文件增长" class="headerlink" title="文件增长"></a>文件增长</h3><p>当我们打开一个 db 时，如果发现该 db 文件为空，会在内存中初始化四个页（4*4k&#x3D;16K），分别是两个元信息页、一个空的空闲列表页和一个空的叶子节点页，然后将其写入 db 文件，然后走正常打开流程。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(db *DB)</span></span> init() <span class="type">error</span> &#123;</span><br><span class="line">  <span class="comment">// 设置页大小与操作系统一致</span></span><br><span class="line">  db.pageSize = os.Getpagesize()</span><br><span class="line"></span><br><span class="line">  buf := <span class="built_in">make</span>([]<span class="type">byte</span>, db.pageSize*<span class="number">4</span>)</span><br><span class="line">  <span class="comment">// 在 buffer 中创建两个元信息页.</span></span><br><span class="line">  <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">2</span>; i++ &#123;</span><br><span class="line">    p := db.pageInBuffer(buf[:], pgid(i))</span><br><span class="line">    p.id = pgid(i)</span><br><span class="line">    p.flags = metaPageFlag</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化元信息页.</span></span><br><span class="line">    m := p.meta()</span><br><span class="line">    m.magic = magic</span><br><span class="line">    m.version = version</span><br><span class="line">    m.pageSize = <span class="type">uint32</span>(db.pageSize)</span><br><span class="line">    m.freelist = <span class="number">2</span></span><br><span class="line">    m.root = bucket&#123;root: <span class="number">3</span>&#125;</span><br><span class="line">    m.pgid = <span class="number">4</span></span><br><span class="line">    m.txid = txid(i)</span><br><span class="line">    m.checksum = m.sum64()</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 在 pgid=2 的页写入一个空的空闲列表.</span></span><br><span class="line">  p := db.pageInBuffer(buf[:], pgid(<span class="number">2</span>))</span><br><span class="line">  p.id = pgid(<span class="number">2</span>)</span><br><span class="line">  p.flags = freelistPageFlag</span><br><span class="line">  p.count = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 在 pgid=3 的页写入一个空的叶子元素.</span></span><br><span class="line">  p = db.pageInBuffer(buf[:], pgid(<span class="number">3</span>))</span><br><span class="line">  p.id = pgid(<span class="number">3</span>)</span><br><span class="line">  p.flags = leafPageFlag</span><br><span class="line">  p.count = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 将 buffer 中的这四个页写入数据文件并刷盘</span></span><br><span class="line">  <span class="keyword">if</span> _, err := db.ops.writeAt(buf, <span class="number">0</span>); err != <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> err</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> err := fdatasync(db); err != <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> err</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>随着数据的不断写入，需要申请新的页。boltdb 首先会去 freelist 中找有无可重复利用的页，如果没有，就只能进行 re-mmap（先 mumap 在 mmap），扩大 db 文件。每次扩大会进行倍增（因此从 16K * 2 &#x3D; 32K 开始），到达 1G 后，再次扩大会每次新增 1G。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(db *DB)</span></span> mmapSize(size <span class="type">int</span>) (<span class="type">int</span>, <span class="type">error</span>) &#123;</span><br><span class="line">  <span class="comment">// 从 32KB 开始，直到 1GB.</span></span><br><span class="line">  <span class="keyword">for</span> i := <span class="type">uint</span>(<span class="number">15</span>); i &lt;= <span class="number">30</span>; i++ &#123;</span><br><span class="line">    <span class="keyword">if</span> size &lt;= <span class="number">1</span>&lt;&lt;i &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="number">1</span> &lt;&lt; i, <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Verify the requested size is not above the maximum allowed.</span></span><br><span class="line">  <span class="keyword">if</span> size &gt; maxMapSize &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>, fmt.Errorf(<span class="string">&quot;mmap too large&quot;</span>)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 对齐到 maxMmapStep = 1G</span></span><br><span class="line">  sz := <span class="type">int64</span>(size)</span><br><span class="line">  <span class="keyword">if</span> remainder := sz % <span class="type">int64</span>(maxMmapStep); remainder &gt; <span class="number">0</span> &#123;</span><br><span class="line">    sz += <span class="type">int64</span>(maxMmapStep) - remainder</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 对齐到 db.pageSize</span></span><br><span class="line">  pageSize := <span class="type">int64</span>(db.pageSize)</span><br><span class="line">  <span class="keyword">if</span> (sz % pageSize) != <span class="number">0</span> &#123;</span><br><span class="line">    sz = ((sz / pageSize) + <span class="number">1</span>) * pageSize</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 不能超过 maxMapSize</span></span><br><span class="line">  <span class="keyword">if</span> sz &gt; maxMapSize &#123;</span><br><span class="line">    sz = maxMapSize</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="type">int</span>(sz), <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在 32位 机器上文件最大不能超过 <code>maxMapSize</code> &#x3D; 2G；在 64 位机器上，文件上限为 256T。</p>
<h3 id="读写流程"><a href="#读写流程" class="headerlink" title="读写流程"></a>读写流程</h3><p>在打开一个已经存在的 db 时，会首先将 db 文件映射到内存空间，然后解析元信息页，最后加载空闲列表。</p>
<p>在 db 进行读取时，会按需将访问路径上的 page 加载到内存，并转换为 node，进行缓存。</p>
<p>在 db 进行修改时，使用 COW 原则，所有修改不在原地，而是在改动前先复制一份。如果叶子节点 node 需要修改，则 root bucket 到该 node 路径上所涉及的所有节点都需要修改。这些节点都需要新申请空间，然后持久化，这些和事务的实现息息相关，之后会在本系列事务文章中做详细说明。</p>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>boltdb 在数据组织方面只使用了两个概念：页（page） 和节点 （node）。每个数据库对应一个文件，每个文件中包含一系列线性组织的页。页的大小固定，依其性质不同，分为四种类型：元信息页、空闲列表页、叶子节点页、分支节点页。打开数据库时，会渐次进行以下操作：</p>
<ol>
<li>利用 mmap 将数据库文件映射到内存空间。</li>
<li>解析元信息页，获取空闲列表页 id 和 root bucket 页 id。</li>
<li>依据空闲列表页 id ，将所有空闲页列表载入内存。</li>
<li>依据 root bucket 起始页地址，解析 root bucket 根节点。</li>
<li>根据读写需求，从树根开始遍历，按需将访问路径上的数据页（分支节点页和叶子节点页）载入内存成为节点（node）。</li>
</ol>
<p>可以看出，节点分两种类型：分支节点（branch node）和叶子节点（leaf node）。</p>
<p>另外需要注意的是，由于嵌套 bucket 的存在，导致这一块稍微有点不好理解。在下一篇 boltdb 的<strong>索引设计</strong>中，将详细剖析 boltdb 是如何组织多个 bucket 以及单个 bucket 内的 B+ 树索引的。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol>
<li>github，<a target="_blank" rel="noopener" href="https://github.com/boltdb/bolt">boltdb repo</a></li>
<li>我叫尤加利，<a target="_blank" rel="noopener" href="https://youjiali1995.github.io/storage/boltdb/">boltdb 源码分析</a></li>
</ol>
<hr>
<p>我是青藤木鸟，一个喜欢摄影的存储工程师，欢迎关注我的公众号：“木鸟杂记”。</p>
<p><img src="https://i.loli.net/2021/03/30/utbeLDk2UTxdc8R.jpg" alt="wx-distributed-system-muniao-s.jpg"></p>

        <script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-4303078477555566"
     crossorigin="anonymous"></script>
<ins class="adsbygoogle"
     style="display:block; text-align:center;"
     data-ad-layout="in-article"
     data-ad-format="fluid"
     data-ad-client="ca-pub-4303078477555566"
     data-ad-slot="1270196241"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
    </div>

    
    
    
      
  <div class="popular-posts-header">不妨一读</div>
  <ul class="popular-posts">
    <li class="popular-posts-item">
      <div class="popular-posts-title"><a href="/2020/12/14/bolt-index-design/" rel="bookmark">Boltdb 源码导读（二）：Boltdb 索引设计</a></div>
    </li>
    <li class="popular-posts-item">
      <div class="popular-posts-title"><a href="/2021/04/02/bolt-transaction/" rel="bookmark">Boltdb 源码导读（三）：Boltdb 事务实现</a></div>
    </li>
    <li class="popular-posts-item">
      <div class="popular-posts-title"><a href="/2019/12/07/bazel-build-golang/" rel="bookmark">Bazel 构建 Golang 项目</a></div>
    </li>
    <li class="popular-posts-item">
      <div class="popular-posts-title"><a href="/2020/01/06/go-value-pointer-method/" rel="bookmark">Golang 笔记（一）：值方法和指针方法（Value Methods vs Pointer Methods）</a></div>
    </li>
    <li class="popular-posts-item">
      <div class="popular-posts-title"><a href="/2020/07/12/go-context/" rel="bookmark">Golang 笔记（二）：Context 源码剖析</a></div>
    </li>
    <li class="popular-posts-item">
      <div class="popular-posts-title"><a href="/2021/01/09/go-slice/" rel="bookmark">Golang 笔记（三）：一种理解 Slice 的模型</a></div>
    </li>
  </ul>

        <div class="reward-container">
  <div></div>
  <button onclick="var qr = document.getElementById('qr'); qr.style.display = (qr.style.display === 'none') ? 'block' : 'none';">
    打赏
  </button>
  <div id="qr" style="display: none;">
      
      <div style="display: inline-block;">
        <img src="https://i.postimg.cc/5yGJWLQW/image.png" alt="木鸟杂记 微信支付">
        <p>微信支付</p>
      </div>

  </div>
</div>


      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/%E5%AD%98%E5%82%A8/" rel="tag"># 存储</a>
              <a href="/tags/golang/" rel="tag"># golang</a>
              <a href="/tags/go/" rel="tag"># go</a>
              <a href="/tags/boltdb/" rel="tag"># boltdb</a>
              <a href="/tags/kv-engine/" rel="tag"># kv engine</a>
              <a href="/tags/%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/" rel="tag"># 源码阅读</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2020/11/18/leveldb-data-structures-bloom-filter/" rel="prev" title="漫谈 LevelDB 数据结构（二）：布隆过滤器（Bloom Filter）">
      <i class="fa fa-chevron-left"></i> 漫谈 LevelDB 数据结构（二）：布隆过滤器（Bloom Filter）
    </a></div>
      <div class="post-nav-item">
    <a href="/2020/12/14/bolt-index-design/" rel="next" title="Boltdb 源码导读（二）：Boltdb 索引设计">
      Boltdb 源码导读（二）：Boltdb 索引设计 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          
    <div class="comments" id="gitalk-container"></div>

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%BC%95%E5%AD%90"><span class="nav-number">1.</span> <span class="nav-text">引子</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%A6%82%E8%BF%B0"><span class="nav-number">2.</span> <span class="nav-text">概述</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%A1%B6%E5%B1%82%E7%BB%84%E7%BB%87"><span class="nav-number">2.1.</span> <span class="nav-text">顶层组织</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%A1%B5%E5%92%8C%E8%8A%82%E7%82%B9"><span class="nav-number">2.2.</span> <span class="nav-text">页和节点</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%A1%B5%E6%A0%BC%E5%BC%8F%E5%92%8C%E5%86%85%E5%AD%98%E8%A1%A8%E7%A4%BA"><span class="nav-number">3.</span> <span class="nav-text">页格式和内存表示</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%85%83%E4%BF%A1%E6%81%AF%E9%A1%B5%EF%BC%88metaPage%EF%BC%89"><span class="nav-number">3.1.</span> <span class="nav-text">元信息页（metaPage）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%A9%BA%E9%97%B2%E5%88%97%E8%A1%A8%E9%A1%B5%EF%BC%88freelistPage%EF%BC%89"><span class="nav-number">3.2.</span> <span class="nav-text">空闲列表页（freelistPage）</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%A9%BA%E9%97%B2%E5%88%97%E8%A1%A8%E8%BD%AC%E5%8C%96%E4%B8%BA-page"><span class="nav-number">3.2.1.</span> <span class="nav-text">空闲列表转化为 page</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%A9%BA%E9%97%B2%E5%88%97%E8%A1%A8%E4%BB%8E-page-%E4%B8%AD%E5%8A%A0%E8%BD%BD"><span class="nav-number">3.2.2.</span> <span class="nav-text">空闲列表从 page 中加载</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%A9%BA%E9%97%B2%E5%88%97%E8%A1%A8%E5%88%86%E9%85%8D"><span class="nav-number">3.2.3.</span> <span class="nav-text">空闲列表分配</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8F%B6%E5%AD%90%E8%8A%82%E7%82%B9%E9%A1%B5%EF%BC%88leafPage%EF%BC%89"><span class="nav-number">3.3.</span> <span class="nav-text">叶子节点页（leafPage）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%86%E6%94%AF%E8%8A%82%E7%82%B9%E9%A1%B5%EF%BC%88branchPage%EF%BC%89"><span class="nav-number">3.4.</span> <span class="nav-text">分支节点页（branchPage）</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%BD%AC%E6%8D%A2%E6%B5%81%E7%A8%8B"><span class="nav-number">4.</span> <span class="nav-text">转换流程</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%96%87%E4%BB%B6%E5%A2%9E%E9%95%BF"><span class="nav-number">4.1.</span> <span class="nav-text">文件增长</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%AF%BB%E5%86%99%E6%B5%81%E7%A8%8B"><span class="nav-number">4.2.</span> <span class="nav-text">读写流程</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%B0%8F%E7%BB%93"><span class="nav-number">5.</span> <span class="nav-text">小结</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8F%82%E8%80%83"><span class="nav-number">6.</span> <span class="nav-text">参考</span></a></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="木鸟杂记"
      src="/img/logo.jpg">
  <p class="site-author-name" itemprop="name">木鸟杂记</p>
  <div class="site-description" itemprop="description">一个喜欢摄影的分布式程序员</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">94</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">32</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
        <span class="site-state-item-count">160</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <span class="exturl" data-url="aHR0cHM6Ly93d3cuemhpaHUuY29tL3Blb3BsZS9xdG11bmlhbw==" title="知乎 → https:&#x2F;&#x2F;www.zhihu.com&#x2F;people&#x2F;qtmuniao"><i class="zhihu fa-fw"></i>知乎</span>
      </span>
      <span class="links-of-author-item">
        <span class="exturl" data-url="aHR0cHM6Ly9zcGFjZS5iaWxpYmlsaS5jb20vMzA5MzM4MTI=" title="B站 → https:&#x2F;&#x2F;space.bilibili.com&#x2F;30933812"><i class="bzhan fa-fw"></i>B站</span>
      </span>
      <span class="links-of-author-item">
        <span class="exturl" data-url="aHR0cHM6Ly9xdG11bmlhby50dWNob25nLmNvbS8=" title="图虫 → https:&#x2F;&#x2F;qtmuniao.tuchong.com&#x2F;"><i class="tuchong fa-fw"></i>图虫</span>
      </span>
  </div>


  <div class="links-of-blogroll motion-element">
    <div class="links-of-blogroll-title"><i class="link fa-fw"></i>
      friends
    </div>
    <ul class="links-of-blogroll-list">
        <li class="links-of-blogroll-item">
          <span class="exturl" data-url="aHR0cHM6Ly9sYWlrZTltLmNvbQ==" title="https:&#x2F;&#x2F;laike9m.com">laike9m</span>
        </li>
        <li class="links-of-blogroll-item">
          <span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNoYW5na3VuLmRlLw==" title="https:&#x2F;&#x2F;blog.changkun.de&#x2F;">Changkun Ou</span>
        </li>
        <li class="links-of-blogroll-item">
          <span class="exturl" data-url="aHR0cHM6Ly93d3cua2F3YWJhbmdnYS5jb20=" title="https:&#x2F;&#x2F;www.kawabangga.com">卡瓦邦噶！</span>
        </li>
        <li class="links-of-blogroll-item">
          <span class="exturl" data-url="aHR0cHM6Ly95YW5iaW4uYmxvZw==" title="https:&#x2F;&#x2F;yanbin.blog">隔叶黄莺</span>
        </li>
        <li class="links-of-blogroll-item">
          <span class="exturl" data-url="aHR0cHM6Ly9nZWVrdHV0dS5jb20=" title="https:&#x2F;&#x2F;geektutu.com">极客兔兔</span>
        </li>
        <li class="links-of-blogroll-item">
          <span class="exturl" data-url="aHR0cHM6Ly94aWFveW91NjYuY29t" title="https:&#x2F;&#x2F;xiaoyou66.com">小游网</span>
        </li>
        <li class="links-of-blogroll-item">
          <span class="exturl" data-url="aHR0cDovL2dhb2NlZ2VnZS5jb20vQmxvZw==" title="http:&#x2F;&#x2F;gaocegege.com&#x2F;Blog">高策</span>
        </li>
        <li class="links-of-blogroll-item">
          <span class="exturl" data-url="aHR0cHM6Ly9yMTJmLmNvbQ==" title="https:&#x2F;&#x2F;r12f.com">Soul Orbit</span>
        </li>
        <li class="links-of-blogroll-item">
          <span class="exturl" data-url="aHR0cHM6Ly90YW54aW55dS53b3Jr" title="https:&#x2F;&#x2F;tanxinyu.work">谭新宇</span>
        </li>
        <li class="links-of-blogroll-item">
          <span class="exturl" data-url="aHR0cHM6Ly9penVhbHpoeS5jbi8=" title="https:&#x2F;&#x2F;izualzhy.cn&#x2F;">Ying's Blog</span>
        </li>
        <li class="links-of-blogroll-item">
          <span class="exturl" data-url="aHR0cHM6Ly9taWFuYmFvZHVvLmNvbS9vL2F1dGhvci1hV3lVbTIwPQ==" title="https:&#x2F;&#x2F;mianbaoduo.com&#x2F;o&#x2F;author-aWyUm20&#x3D;">我的面包多</span>
        </li>
        <li class="links-of-blogroll-item">
          <span class="exturl" data-url="aHR0cHM6Ly93d3cudnVsdHIuY29tLz9yZWY9ODMyOTc0OC00Rg==" title="https:&#x2F;&#x2F;www.vultr.com&#x2F;?ref&#x3D;8329748-4F">vultr vps 注册送 $50</span>
        </li>
    </ul>
  </div>


      </div>

      <div class="site-overview-wrap">
        <div class="motion-element sidebar-ads">
<script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<!-- 侧边栏-1 -->
<ins class="adsbygoogle"
style="display:inline-block;width:280px;height:100px"
data-ad-client="ca-pub-4303078477555566"
data-ad-slot="4071023010"></ins>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
</div>
<div style="
    font-size: 0.3em;
    height: 20px;
    margin-top: -10px;
">轻点广告 请我喝杯茶</div>

      </div>
        <div class="back-to-top motion-element">
          <i class="fa fa-arrow-up"></i>
          <span>0%</span>
        </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 2017 – 
  <span itemprop="copyrightYear">2023</span>
  <span class="with-love">
    <i class="user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">木鸟杂记</span>
</div>
  <div class="powered-by">由 <span class="exturl theme-link" data-url="aHR0cHM6Ly9oZXhvLmlv">Hexo</span> & <span class="exturl theme-link" data-url="aHR0cHM6Ly90aGVtZS1uZXh0Lm9yZw==">NexT.Gemini</span> 强力驱动
  </div>

        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="//cdn.jsdelivr.net/npm/medium-zoom@1/dist/medium-zoom.min.js"></script>
  <script src="//cdn.jsdelivr.net/npm/pangu@4/dist/browser/pangu.min.js"></script>

<script src="/js/utils.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  
  <script>
    (function(){
      var canonicalURL, curProtocol;
      //Get the <link> tag
      var x=document.getElementsByTagName("link");
		//Find the last canonical URL
		if(x.length > 0){
			for (i=0;i<x.length;i++){
				if(x[i].rel.toLowerCase() == 'canonical' && x[i].href){
					canonicalURL=x[i].href;
				}
			}
		}
    //Get protocol
	    if (!canonicalURL){
	    	curProtocol = window.location.protocol.split(':')[0];
	    }
	    else{
	    	curProtocol = canonicalURL.split(':')[0];
	    }
      //Get current URL if the canonical URL does not exist
	    if (!canonicalURL) canonicalURL = window.location.href;
	    //Assign script content. Replace current URL with the canonical URL
      !function(){var e=/([http|https]:\/\/[a-zA-Z0-9\_\.]+\.baidu\.com)/gi,r=canonicalURL,t=document.referrer;if(!e.test(r)){var n=(String(curProtocol).toLowerCase() === 'https')?"https://sp0.baidu.com/9_Q4simg2RQJ8t7jm9iCKT-xh_/s.gif":"//api.share.baidu.com/s.gif";t?(n+="?r="+encodeURIComponent(document.referrer),r&&(n+="&l="+r)):r&&(n+="?l="+r);var i=new Image;i.src=n}}(window);})();
  </script>















  

  
  <script src="//cdn.jsdelivr.net/npm/quicklink@1/dist/quicklink.umd.js"></script>
  <script>
      window.addEventListener('load', () => {
      quicklink({
        timeout : 3000,
        priority: true,
        ignores : [uri => uri.includes('#'),uri => uri === 'https://www.qtmuniao.com/2020/11/29/bolt-data-organised/',]
      });
      });
  </script>

<link rel="stylesheet" href="//cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.css">

<script>
NexT.utils.loadComments(document.querySelector('#gitalk-container'), () => {
  NexT.utils.getScript('//cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.js', () => {
    var gitalk = new Gitalk({
      clientID    : '96b4b5363c4817dc1f62',
      clientSecret: '9e46a83f9fda0c5d3aabaaa64b60c027763cb677',
      repo        : 'blog-comment',
      owner       : 'songpengwei',
      admin       : ['songpengwei'],
      id          : 'eb6434aae10cabea5f72b5261c2265a1',
        language: '',
      distractionFreeMode: true
    });
    gitalk.render('gitalk-container');
  }, window.Gitalk);
});
</script>

</body>
</html>
