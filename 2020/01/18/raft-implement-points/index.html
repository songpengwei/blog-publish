<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta name="360-site-verification" content="25801ebe32430d2890004839ea377da2" />
  <script data-ad-client="ca-pub-4303078477555566" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-muniao.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-muniao.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-muniao.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">
  <meta name="google-site-verification" content="epFgX0s_0RM3CdjwFcsewfXzPov2g8s9ZBOLyaIUH-o">
  <meta name="baidu-site-verification" content="btK4cBsWUficCOsR">

<link rel="stylesheet" href="/css/main.css">

<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Noto Serif SC:300,300italic,400,400italic,700,700italic|Noto Sans SC:300,300italic,400,400italic,700,700italic|Fira Code:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext">
<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"www.qtmuniao.com","root":"/","scheme":"Gemini","version":"7.8.0","exturl":true,"sidebar":{"position":"right","display":"post","padding":18,"offset":12,"onmobile":false,"Muse | Mist":300,"Pisces | Gemini":300,"width":300},"copycode":{"enable":true,"show_result":false,"style":"default"},"back2top":{"enable":true,"sidebar":true,"scrollpercent":true},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":true,"lazyload":false,"pangu":true,"comments":{"style":"tabs","active":"gitalk","storage":true,"lazyload":false,"nav":{"gitalk":{"order":-2}},"activeClass":"gitalk"},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":false,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="引子18年的时候做过一些 6.824，旧文在此，无奈做到 Part 2C，无论如何也跑不过测试，便一直搁置起来。但在后来的日子，却时时念起此门神课，心下伤感。拖到今日，终于可以来还愿了。 这次能跑过所有测试，原因有三：一来，之前做过一次，很多原理还留有印象；二来，这一年多在工作上有了很多分布式系统的实践；三来，golang 的驾驭上也精进了一些。但是在做的过程中，仍然遇到了大量令人纠结的细节，为了">
<meta property="og:type" content="article">
<meta property="og:title" content="MIT 6.824 2020 Raft 实现细节备忘">
<meta property="og:url" content="https://www.qtmuniao.com/2020/01/18/raft-implement-points/index.html">
<meta property="og:site_name" content="木鸟杂记">
<meta property="og:description" content="引子18年的时候做过一些 6.824，旧文在此，无奈做到 Part 2C，无论如何也跑不过测试，便一直搁置起来。但在后来的日子，却时时念起此门神课，心下伤感。拖到今日，终于可以来还愿了。 这次能跑过所有测试，原因有三：一来，之前做过一次，很多原理还留有印象；二来，这一年多在工作上有了很多分布式系统的实践；三来，golang 的驾驭上也精进了一些。但是在做的过程中，仍然遇到了大量令人纠结的细节，为了">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://i.loli.net/2020/02/09/mfESApyVoB1cPRe.png">
<meta property="article:published_time" content="2020-01-18T14:02:26.000Z">
<meta property="article:modified_time" content="2024-03-04T01:15:50.407Z">
<meta property="article:author" content="木鸟杂记">
<meta property="article:tag" content="distributed system">
<meta property="article:tag" content="分布式系统">
<meta property="article:tag" content="Raft">
<meta property="article:tag" content="实现">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://i.loli.net/2020/02/09/mfESApyVoB1cPRe.png">

<link rel="canonical" href="https://www.qtmuniao.com/2020/01/18/raft-implement-points/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>MIT 6.824 2020 Raft 实现细节备忘 | 木鸟杂记</title>
  
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-101943025-1"></script>
    <script>
      if (CONFIG.hostname === location.hostname) {
        window.dataLayer = window.dataLayer || [];
        function gtag(){dataLayer.push(arguments);}
        gtag('js', new Date());
        gtag('config', 'UA-101943025-1');
      }
    </script>


  <script>
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?1fb8def00cacde7d41798806b1150188";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>




  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">木鸟杂记</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">分布式系统，数据库，存储</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-photos">

    <a href="/photos/" rel="section"><i class="fa fa-image fa-fw"></i>相册</a>

  </li>
        <li class="menu-item menu-item-sparks">

    <a href="/sparks/" rel="section"><i class="fa fa-spinner fa-fw"></i>短想法</a>

  </li>
        <li class="menu-item menu-item-ddia">

    <span class="exturl" data-url="aHR0cHM6Ly9kZGlhLnF0bXVuaWFvLmNvbS8="><i class="fa fa-book fa-fw"></i>DDIA</span>

  </li>
        <li class="menu-item menu-item-podcast">

    <a href="/podcast/" rel="section"><i class="fa fa-heart fa-fw"></i>播客和书</a>

  </li>
        <li class="menu-item menu-item-service">

    <a href="/service/" rel="section"><i class="fa fa-dollar-sign fa-fw"></i>付费服务</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="reading-progress-bar"></div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://www.qtmuniao.com/2020/01/18/raft-implement-points/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/img/logo.jpg">
      <meta itemprop="name" content="木鸟杂记">
      <meta itemprop="description" content="一个喜欢摄影的分布式程序员">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="木鸟杂记">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          MIT 6.824 2020 Raft 实现细节备忘
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-01-18 22:02:26" itemprop="dateCreated datePublished" datetime="2020-01-18T22:02:26+08:00">2020-01-18</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2024-03-04 09:15:50" itemprop="dateModified" datetime="2024-03-04T09:15:50+08:00">2024-03-04</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/" itemprop="url" rel="index"><span itemprop="name">分布式系统</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/Raft/" itemprop="url" rel="index"><span itemprop="name">Raft</span></a>
                </span>
            </span>

          
            <span class="post-meta-item" title="阅读次数" id="busuanzi_container_page_pv" style="display: none;">
              <span class="post-meta-item-icon">
                <i class="eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span id="busuanzi_value_page_pv"></span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h2 id="引子"><a href="#引子" class="headerlink" title="引子"></a>引子</h2><p>18年的时候做过一些 6.824，旧文<a href="https://www.qtmuniao.com/categories/courses/">在此</a>，无奈做到 Part 2C，无论如何也跑不过测试，便一直搁置起来。但在后来的日子，却时时念起此门神课，心下伤感。拖到今日，终于可以来还愿了。</p>
<p>这次能跑过所有测试，原因有三：一来，之前做过一次，很多原理还留有印象；二来，这一年多在工作上有了很多分布式系统的实践；三来，golang 的驾驭上也精进了一些。但是在做的过程中，仍然遇到了大量令人纠结的细节，为了方便日后回顾，将这些细节梳理一下，记在此处。若能好巧对其他做此门课的人有些微启发，则又是快事一件了。</p>
<h2 id="6-824-与-Raft"><a href="#6-824-与-Raft" class="headerlink" title="6.824 与 Raft"></a>6.824 与 Raft</h2><p><span class="exturl" data-url="aHR0cHM6Ly9wZG9zLmNzYWlsLm1pdC5lZHUvNi44MjQv">6.824<i class="fa fa-external-link-alt"></i></span> 是一门关于分布式系统的非常棒的公开课，做课程实验的过程中时时惊叹于其构思之精巧、材料准备之翔实。MIT 的大师们能将这样精华的课程开放出来，实乃名校和大师们的气度，更是我们计算机人的幸事。</p>
<p>Raft 是一个面向理解的分布式共识（consensus）协议。分布式共识算法是分布式领域非常非常经典的问题，同时也是分布式系统中非常难的一块，直观的说，就如同流沙上打下分布式系统大楼的地基。不可靠的网络、易故障的主机，造成的状态变化之复杂，实在不是一般人能在脑中模拟得了的。本人愚钝，只能是感性把握加细节堆叠，堪堪有些认识。说回 Raft，有同领域 Paxos 珠玉在前，何以 Raft 仍能脱颖而出？应该是抓住了以下两点：</p>
<ol>
<li><strong>易于理解</strong>。Paxos 是出了名的难以理解，因此也就难以飞入寻常百姓家。而 Raft 通过解耦出多个模块，将算法复杂度进行降维，大大降低了一般人的理解难度。此外，Raft 还有很多精巧的设计，以尽可能避免引入复杂度，从而进一步减轻大家的心智负担。</li>
<li><strong>易于实现</strong>。易于理解客观上会导致利于实现，但不等同于就能据此产出优秀系统。如果理解流于感性，则实现成空中楼阁。Raft 论文的厉害之处就在于既有感性把握又有细节组织，几乎就是一个系统的设计文档，还是详细设计文档。</li>
</ol>
<p>要想做好该<span class="exturl" data-url="aHR0cHM6Ly9wZG9zLmNzYWlsLm1pdC5lZHUvNi44MjQvbGFicy9sYWItUmFmdC5odG1s">实验<i class="fa fa-external-link-alt"></i></span>，需要涉猎大量的材料，我把实验中提到的和我看到的汇总在文末。当然，还有英文劝退。虽然我最后测试用例都过了，但仍有很多没实现好的点以及不理解之处。</p>
<p>注：后续，2023 年<span class="exturl" data-url="aHR0cHM6Ly9hdjZodWYyZTFrLmZlaXNodS5jbi9kb2N4L0pDc3NkbGdGNG9SQURjeHhMcW5jUHBSQ241Yg==">又做了一次<i class="fa fa-external-link-alt"></i></span>，终于理清楚了大部分点。</p>
<span id="more"></span>

<p><em>作者：木鸟杂记 <a href="https://www.qtmuniao.com/">https://www.qtmuniao.com</a>, 转载请注明出处</em></p>
<h2 id="整体结构"><a href="#整体结构" class="headerlink" title="整体结构"></a>整体结构</h2><p>该实验（2020年版本）分为三个部分，分别是 Part 2A：leader 选举、Part 2B： 日志同步、lab2C：状态备份。</p>
<p>我在实现的时候没有用过多的 channel，状态都是通过加锁来阻塞式改变的。我注意到网上有一些实现将所有状态变化都用 channel 控制，这样异步实现可能会效率高些，但可读性稍差。我的实现基本遵从论文叙述，在代码组织上可以概括为<strong>三个状态</strong>和<strong>三个 Loop</strong>。</p>
<h3 id="三个状态"><a href="#三个状态" class="headerlink" title="三个状态"></a><strong>三个状态</strong></h3><p><em>Follower</em>、<em>Candidate</em>、<em>Leader</em>。并据此定义了三个函数：<em>becomeFollower</em>、<em>becomeCandidate</em>、<em>becomeLeader</em>，分别封装了一些 Raft Peer 内部的状态变化。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rf *Raft)</span></span> becomeCandidate() &#123;</span><br><span class="line">  rf.role = CANDIDATE</span><br><span class="line">  rf.currentTerm++</span><br><span class="line">  rf.votedFor = rf.me</span><br><span class="line">  rf.persist()</span><br><span class="line">  DPrintf(<span class="string">&quot;%s change to candidate&quot;</span>, rf)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rf *Raft)</span></span> becomeFollower(term <span class="type">int</span>) &#123;</span><br><span class="line">  rf.role = FOLLOWER</span><br><span class="line">  rf.currentTerm = term</span><br><span class="line">  <span class="keyword">if</span> rf.currentTerm &gt; term &#123;</span><br><span class="line">    rf.votedFor = <span class="number">-1</span></span><br><span class="line">  &#125;</span><br><span class="line">  rf.persist()</span><br><span class="line">  rf.electionTimer.Reset(getRandElectTimeout())</span><br><span class="line">  DPrintf(<span class="string">&quot;%s change to follower with term %d&quot;</span>, rf, term)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rf *Raft)</span></span> becomeLeader() &#123;</span><br><span class="line">  rf.role = LEADER</span><br><span class="line">  rf.leaderID = rf.me</span><br><span class="line">  rf.persist()</span><br><span class="line">  <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; rf.PeersNum; i++ &#123;</span><br><span class="line">    rf.matchIndex[i] = <span class="number">0</span></span><br><span class="line">    rf.nextIndex[i] = <span class="built_in">len</span>(rf.log)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  rf.pingTimer.Reset(heartbeatInterval)</span><br><span class="line">  <span class="keyword">go</span> rf.pingLoop()</span><br><span class="line">  DPrintf(<span class="string">&quot;%s change to leader&quot;</span>, rf)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="三个循环"><a href="#三个循环" class="headerlink" title="三个循环"></a><strong>三个循环</strong></h3><p>三个 goroutine：<em>electionLoop</em>，<em>pingLoop</em>，<em>applyLoop</em>。其中，前两个 loop 都由 timer 驱动， <em>electionLoop</em> 只在 Peer 不为 Leader 时执行选举逻辑，而 <em>pingLoop</em> 是在每次 Peer 当选为 Leader 时启动，并在失去 Leader 身份后及时退出的。也就是说，对于同一个 Peer，这两个 Loop 实现为了互斥的。</p>
<p><strong>electionLoop</strong> 是 Follower 超时变为 Candidate 后进行选举的 Loop。它为后台常驻 goroutine，但是检测到自己是 Leader 时会跳过执行循环体（跳过选举），毕竟谁也不会主动发起选举推翻自己。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rf *Raft)</span></span> electionLoop() &#123;</span><br><span class="line">  <span class="keyword">for</span> &#123;</span><br><span class="line">    &lt;-rf.electionTimer.C</span><br><span class="line">    rf.electionTimer.Reset(getRandElectTimeout())</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> rf.role == LEADER &#123;</span><br><span class="line">      <span class="keyword">continue</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    rf.mu.Lock()</span><br><span class="line">    rf.becomeCandidate()</span><br><span class="line">    <span class="comment">// request vote from each Peer except itself</span></span><br><span class="line">    rf.mu.Unlock()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>pingLoop</strong> 是 Candidate 当选为 Leader 后进行心跳的 Loop，并在心跳的来回中完成日志同步。该 Loop 是在 becomeLeader 函数中被启动的 goroutine，一旦检测到自己不为 Leader 后便立即退出，毕竟 Peer 都是高度自觉的，若是人人欺诈，就永远达不成一致了。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rf *Raft)</span></span> pingLoop() &#123;</span><br><span class="line">  <span class="keyword">for</span> &#123;</span><br><span class="line">    rf.mu.Lock()</span><br><span class="line">    <span class="keyword">if</span> rf.role != LEADER &#123;</span><br><span class="line">      rf.mu.Unlock()</span><br><span class="line">      <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// append entries to each Peer except itself</span></span><br><span class="line">    rf.mu.Unlock()</span><br><span class="line"></span><br><span class="line">    &lt;-rf.pingTimer.C</span><br><span class="line">    rf.pingTimer.Reset(heartbeatInterval)</span><br><span class="line">    DPrintf(<span class="string">&quot;%v start next ping round&quot;</span>, rf)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>applyLoop</strong> 最简单，就是将已经 commit 的 log 不断应用到状态机，也是个后台常驻 goroutine。如此设计的妙处在于解耦。即不是每次 commit 后立即 apply，而是由额外的 goroutine 统一执行，以避免多次 commit 同一个 index（由于大多数 Peer 响应后就可以 commit，之后再收到其他 Peer 的响应，就可能造成多次 commit），进而导致多次 apply。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rf *Raft)</span></span> applyLoop() &#123;</span><br><span class="line">  <span class="keyword">for</span> &#123;</span><br><span class="line">    time.Sleep(<span class="number">10</span> * time.Millisecond)</span><br><span class="line">    rf.mu.Lock()</span><br><span class="line">    <span class="keyword">for</span> rf.lastApplied &lt; rf.commitIndex &#123;</span><br><span class="line">      rf.lastApplied++</span><br><span class="line">      rf.apply( rf.lastApplied，rf.log[rf.lastApplied]) <span class="comment">// put to applyChan in the function</span></span><br><span class="line">    &#125;</span><br><span class="line">    rf.mu.Unlock()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="加锁原则"><a href="#加锁原则" class="headerlink" title="加锁原则"></a>加锁原则</h3><p>我是按照<span class="exturl" data-url="aHR0cHM6Ly9wZG9zLmNzYWlsLm1pdC5lZHUvNi44MjQvbGFicy9SYWZ0LWxvY2tpbmcudHh0">实验材料<i class="fa fa-external-link-alt"></i></span>中建议的，用的比较粗暴，基本都是函数粒度的。仅在发生长耗时操作（网络IO）前会释放锁：即每次 RPC （<em>sendRequestVote</em> 和 <em>sendAppendEntries</em>）前。因此效率不会太高，但是易于实现和理解。同时为了保证这次发送过程是原子的（不被中断），使用了一个 channel 来同步，保证给下个 Peer 发送 RPC 前，前一个 RPC 已经准备完了 Args；当然也可以将准备 Args 的过程，拿到 goroutine 之外。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rf *Raft)</span></span> pingLoop() &#123;</span><br><span class="line">  <span class="keyword">for</span> &#123;</span><br><span class="line">    rf.mu.Lock()</span><br><span class="line">    <span class="keyword">if</span> rf.role != LEADER &#123;</span><br><span class="line">      rf.mu.Unlock()</span><br><span class="line">      <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    prepareFinish := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">bool</span>)</span><br><span class="line">    <span class="keyword">for</span> PeerID := <span class="keyword">range</span> rf.Peers &#123;</span><br><span class="line">      <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(id <span class="type">int</span>, pf <span class="keyword">chan</span> <span class="type">bool</span>)</span></span> &#123;</span><br><span class="line">        <span class="comment">// prepare the append entries arguments</span></span><br><span class="line">        pf &lt;- <span class="literal">true</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// [send rpc] -&gt; [wait] -&gt;[handle the reply]</span></span><br><span class="line">      &#125;(PeerID, prepareFinish)</span><br><span class="line"></span><br><span class="line">      &lt;-prepareFinish</span><br><span class="line">    &#125;</span><br><span class="line">    rf.mu.Unlock()</span><br><span class="line"></span><br><span class="line">    &lt;-rf.pingTimer.C</span><br><span class="line">    rf.pingTimer.Reset(heartbeatInterval)</span><br><span class="line">    DPrintf(<span class="string">&quot;%v start next ping round&quot;</span>, rf)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="日志"><a href="#日志" class="headerlink" title="日志"></a>日志</h3><p>我给主要结构体都实现了 <code>String()</code> 函数，以方便返回当前 Peer 的关键状态、 RPC 前后的参数和返回值，从而易于跟踪、调试。以 Raft 结构体为例：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rf *Raft)</span></span> String() <span class="type">string</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> fmt.Sprintf(<span class="string">&quot;[%s:%d;Term:%d;VotedFor:%d;logLen:%v;Commit:%v;Apply:%v]&quot;</span>,</span><br><span class="line">    rf.role, rf.me, rf.currentTerm, rf.votedFor, <span class="built_in">len</span>(rf.log), rf.commitIndex, rf.lastApplied)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="领导者选举（Part-2A-leader-election）"><a href="#领导者选举（Part-2A-leader-election）" class="headerlink" title="领导者选举（Part 2A: leader election）"></a>领导者选举（Part 2A: leader election）</h2><p>Raft 中的任何 Peer（或者说 server） 都处在三种状态之一：Follower、Candidate、Leader。其状态转移图如下：</p>
<p><img src="https://i.loli.net/2020/02/09/mfESApyVoB1cPRe.png" alt="raft-server-state.png"></p>
<p>其中所有 Peer 在启动时都是 Follower，经过一个随机超时后先后变为 Candidate。Candidate 是一个为竞选 Leader 而设计的中间过渡状态。所有的任期（ term） 始于 Candidate（即变成 Candidate 时 term+1），如果能当选则持续到 Leader结束。</p>
<p>Raft 中有一条铁律，就是不论出于什么状态，只要发现自己所处 term 落后于人，就立即改变自己 term 变成 Follower。 term 即为事实上的逻辑时钟，所有投票行为（Candidate 和 Voter[1]）和日志同步（Leader 和 Follower）动作需要所涉及双方在同一个 term 中。</p>
<p>Raft 使用<strong>强势</strong> Leader，只能由 Leader 向 Follower 同步日志，而不能反过来。并且 Leader 本身的日志只会由 Client 进行 Append，不会更改或者删除；由于 Leader 权势巨大，必须为选举设置严苛的门槛，即保证当选的 Candidate 的 log 比过半数的 Peer 更 up-to-date 。因此需要在选举阶段逐一比较 Candidate 和其他 Peer 谁更 up-to-date。根据论文中这段描述：</p>
<blockquote>
<p>Raft determines which of two logs is more up-to-date by comparing the index and term of the last entries in the logs. If the logs have last entries with different terms, then the log with the later term is more up-to-date. If the logs end with the same term, then whichever log is longer is more up-to-date.</p>
</blockquote>
<p>只考虑两组日志的最后一条日志的 index 和 term 即可：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">notLessUpToDate</span><span class="params">(currTerm, currIndex <span class="type">int</span>, dstTerm, dstIndex <span class="type">int</span>)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> currTerm != dstTerm &#123;</span><br><span class="line">    <span class="keyword">return</span> currTerm &gt; dstTerm</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> currIndex &gt;= dstIndex</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>实现的详细描述可以看论文图二，该描述要当做编程语言而非自然语言来对待，因为它十分精确，尤其要特别注意不要遗漏其状态转换时的触发条件。这里不再赘述，仅列出我觉得在实现时，可能有困惑的一些点：</p>
<ol>
<li><p><code>RequestVoteArgs</code> 结构体的字段都要大写，这是测试程序所要求的。</p>
</li>
<li><p><code>AppendEntries</code> 请求、回应结构体、以及发送RPC 的实现，需要自己比对  <code>RequestVote</code> 依样画葫芦。</p>
</li>
<li><p><code>logEntry</code> 也需要自己定义，我实现的就只包含 Term 和 Command 两个字段。</p>
</li>
<li><p>Peer 每一轮（term）至多投一次票，可以通过在给出投票前判断 <code>rf.votedFor</code> 是否为 null [5] 来保证；但同时有另一层意思，即每一轮至少可以投一次票，这就要求在发生 term 改变时，需要及时改变 votedFor 。分两种情况：一是 Follower&#x2F;Candidate  超时变为 Candidate 时，term 会增加 1，这时候先无脑投自己（<code>rf.votedFor = rf.me</code>），然后发起选举；二是在收到其他 Peer 的 RPC 时（包括 Request 和 Reply），发现别人 term 高，变为 Follower 时，也需要及时清空自己之前投票结果（<code>rf.votedFor = -1</code>）以使本轮次可以继续投票。但同 term 的 Candidate 变回 Follower 时，记得不要重置 <code>rf.votedFor</code>。 </p>
</li>
<li><p>Peer 在实现 AppendEntries 时，只要本 Peer 的 term 不高于发起心跳的 Leader 的 term，都要及时变为 Follower，这包含以下几种情况：a. 如果 Peer 较小，则需 term 跟上，然后变 Follower；b. 本来为 Candidate 且 term 相同，要停止选举变为 Follower；c. 本来就是 Follower 且 term 相同 ，便重置下 electionTimer。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> args.Term &lt; rf.currentTerm &#123;</span><br><span class="line">  DPrintf(<span class="string">&quot;%v reject append entry rpc from %v for (term)&quot;</span>, rf, args)</span><br><span class="line">  <span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">rf.becomeFollower(args.Term) <span class="comment">// become follower with term args.Term and reset timer</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>关于 <code>electionTimer</code> 的重置：每次变为 Follower 时，可以重置下 timer。此外，对于Follower&#x2F;Candidate ，还有两种情况需要重置：一是收到 AppendEntries RPC 时；一是投票给某个 Candidate 时。这个推断从图二中 Followers 中这句话来：</p>
<blockquote>
<p>If election timeout elapses without receiving AppendEntries RPC from current leader or granting vote to candidate: convert to candidate</p>
</blockquote>
</li>
<li><p>每次在收到 RPC 的 reply 时，（Candidate 和 Leader）都要检查一下此时是否和发送 RPC 之前状态一致，如果不一致，需要及时退出 goroutine，不在其位，不谋其政。term + role 可以唯一确定某个 Peer 的状态。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// in pingLoop()</span></span><br><span class="line"><span class="keyword">if</span> rf.role != LEADER || rf.currentTerm != args.Term &#123;</span><br><span class="line">  <span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// in electionLoop()</span></span><br><span class="line"><span class="keyword">if</span> rf.role != CANDIDATE || rf.currentTerm != args.Term &#123;</span><br><span class="line">  <span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<p>在做的时候我还想到了一种极端情况，做了下推演。某个 Peer A 与其他 Peer 产生了网络隔离，于是不断超时-选举-超时，从而不断更新 term 到一个很大的值 T。某个时刻 A 与其他 Peer 恢复通信，它发起选举，向每个 Peer 要票。于是剩下的所有 Peer 包括 Leader 发现更大 term：T，就会立即变为 Follower。不过由于 up-to-date 的保证，A 也是成不了 Leader 的。所以这样场景的唯一后果就是 A 一下把大家带入了更高的 term，且成就了别人（可能选出一个不为 A 、不为原 Leader 的其他 Peer）。当然，工程上通常通过 prevVote 来避免 Leader 老被隔离很久的 Peer 中断。</p>
<h2 id="日志同步（Part-2B-log-replication）"><a href="#日志同步（Part-2B-log-replication）" class="headerlink" title="日志同步（Part 2B: log replication）"></a>日志同步（Part 2B: log replication）</h2><p>Leader 接收到 client 请求到应用其包含 command 到状态机大概需要这么几个过程：</p>
<ol>
<li>收到 client 的请求，包含一个 command 参数（<code>Start(command interface&#123;&#125;)</code>）。</li>
<li>Leader 把该请求追加到本地日志（<code>rf.log = append(rf.log, &amp;logEntry&#123;rf.currentTerm, command&#125;)</code>）。</li>
<li>通过心跳并行通知所有 Follower 写入该日志（AppendEntries RPC）。</li>
<li>待大多数 Follower 成功写入后，提交该日志。</li>
<li>通过下次的心跳把 LeaderCommit 广播给所有的 Follower。</li>
<li>每个 Follower 各自 Apply。</li>
</ol>
<p>心跳是定时的，而<strong>同步日志</strong>则是在定时的心跳的过程中完成的。如果 RPC 参数中不携带日志条目，则就是一个简单心跳；如果  RPC 参数中携带日志条目，则是 Leader 告诉该 Follower，我认为你需要同步这些日志。</p>
<p>那么 Leader 是如何得知每个 Follower 需要同步哪些日志呢？</p>
<p>试探。</p>
<p>通过试探得到匹配点，Leader 在匹配点之后的日志便是需要同步给 Follower 的部分。试探匹配点即是 Leader 会依照自己的日志条目，从后往前，不断询问，你有没有存这一条日志？只要发现某条日志 Follower 存了，那么它就是个匹配点，其之前的日志必然一样 [2]。为了实现这个逻辑，raft 论文主要使用了这几个变量： matchIndex[]、nextIndex[] 和 prevLogIndex、prevLogTerm。</p>
<h3 id="matchIndex-和-nextIndex"><a href="#matchIndex-和-nextIndex" class="headerlink" title="matchIndex 和 nextIndex"></a>matchIndex 和 nextIndex</h3><p>这两个数组只对 Leader 有用。其中，<code>matchIndex[]</code> 跟踪 Leader 和每个 Follower 匹配到的日志条目， <code>nextIndex[]</code> 保存要发送每个 Follower 的下一个日志条目。</p>
<p>Candidate 在当选为 Leader 时，会将所有 <code>matchIndex</code> 初始化为 0 [3]，表示现在我不知道每个 Peer 的进度；同时会将所有 <code>nextIndex</code> 初始化为 <code>len(rf.log)</code>，表示要从其前面，即最后一条日志，开始<strong>试探</strong>。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rf *Raft)</span></span> becomeLeader() &#123;</span><br><span class="line">  ...</span><br><span class="line">  <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; rf.peersNum; i++ &#123;</span><br><span class="line">    rf.matchIndex[i] = <span class="number">0</span></span><br><span class="line">    rf.nextIndex[i] = <span class="built_in">len</span>(rf.log)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// in function pingLoop: construct AppendEntriesArgs</span></span><br><span class="line">prevLogIndex := rf.nextIndex[id] - <span class="number">1</span></span><br><span class="line">args := &amp;AppendEntriesArgs&#123;</span><br><span class="line">  Term:         rf.currentTerm,</span><br><span class="line">  LeaderID:     rf.me,</span><br><span class="line">  PrevLogIndex: prevLogIndex,</span><br><span class="line">  PrevLogTerm:  rf.log[prevLogIndex].Term,</span><br><span class="line">  Entries:      rf.log[rf.nextIndex[id]:], <span class="comment">// start from next to the end</span></span><br><span class="line">  LeaderCommit: rf.commitIndex,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里面隐含一个情况，即第一次试探时 <code>args.Entries</code> 是空的，因此对应论文中图二所说的心跳：</p>
<blockquote>
<p>Upon election: send initial empty AppendEntries RPCs (heartbeat) to each server; repeat during idle periods to prevent election timeouts (§5.2)</p>
</blockquote>
<p>以后随着不断向前试探，心跳中携带的日志条目将会越来越多，在实际工程中可能会引发性能问题。</p>
<h3 id="prevLogIndex-和-prevLogTerm"><a href="#prevLogIndex-和-prevLogTerm" class="headerlink" title="prevLogIndex 和 prevLogTerm"></a>prevLogIndex 和 prevLogTerm</h3><p>每次心跳会带上试探信息：<code>prevLogIndex</code> 和 <code>prevLogTerm</code>。Follower 在收到该 RPC时，会看自己是否有这这条日志。如果没有，则其 <code>prevLogIndex</code> 以及之后的日志必然也不匹配，可以删掉。如果有，那 RPC 参数中携带的日志条目就有用了，将其追加到匹配点之后，同时根据 Leader 要求更新 commit 信息 。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> args.PrevLogIndex &gt;= <span class="built_in">len</span>(rf.log) || rf.log[args.PrevLogIndex].Term != args.PrevLogTerm &#123;</span><br><span class="line">  <span class="keyword">if</span> args.PrevLogIndex &lt; <span class="built_in">len</span>(rf.log) &#123; </span><br><span class="line">    rf.log = rf.log[<span class="number">0</span>:args.PrevLogIndex] <span class="comment">// delete the log in prevLogIndex and after it</span></span><br><span class="line">    rf.persist()</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">rf.log = <span class="built_in">append</span>(rf.log[<span class="number">0</span>:args.PrevLogIndex+<span class="number">1</span>], args.Entries...)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> args.LeaderCommit &gt; rf.commitIndex &#123;</span><br><span class="line">  prevIndex := rf.commitIndex</span><br><span class="line">  rf.commitIndex = minInt(args.LeaderCommit, <span class="built_in">len</span>(rf.log)<span class="number">-1</span>)</span><br><span class="line">&#125;</span><br><span class="line">reply.Success = <span class="literal">true</span></span><br></pre></td></tr></table></figure>

<h3 id="Leader-处理回应"><a href="#Leader-处理回应" class="headerlink" title="Leader 处理回应"></a>Leader 处理回应</h3><p>当 Leader 收到该 Follower 的回复时，如果发现匹配上了，则更新 matchIndex 和 nextIndex；否则，继续试探前一条，当然，为了加快匹配速度，我们采用了大跨步向前策略，每次跳过一个 term 而非一个 index[4]。不这么优化，有个测试就跑不过去。<br>当然，有可能这样也过不了，还得给 Follower 的回复增加一些字段，提示 Leader 快速向前。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> reply.Success &#123;</span><br><span class="line">  rf.matchIndex[id] = args.PrevLogIndex + <span class="built_in">len</span>(args.Entries) <span class="comment">// do not depend on len(rf.log)</span></span><br><span class="line">  rf.nextIndex[id] = rf.matchIndex[id] + <span class="number">1</span></span><br><span class="line"></span><br><span class="line">  majorityIndex := getMajoritySameIndex(rf.matchIndex)</span><br><span class="line">  <span class="keyword">if</span> rf.log[majorityIndex].Term == rf.currentTerm &amp;&amp; majorityIndex &gt; rf.commitIndex &#123;</span><br><span class="line">    rf.commitIndex = majorityIndex</span><br><span class="line">    DPrintf(<span class="string">&quot;%v advance commit index to %v&quot;</span>, rf, rf.commitIndex)</span><br><span class="line">  &#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  prevIndex := args.PrevLogIndex</span><br><span class="line">  <span class="keyword">for</span> prevIndex &gt; <span class="number">0</span> &amp;&amp; rf.log[prevIndex].Term == args.PrevLogTerm &#123;</span><br><span class="line">    prevIndex--</span><br><span class="line">  &#125;</span><br><span class="line">  rf.nextIndex[id] = prevIndex + <span class="number">1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="一些点"><a href="#一些点" class="headerlink" title="一些点"></a>一些点</h3><p>照例，列出我实现中遇到的一些问题 or Bug：</p>
<ol>
<li><p>如何决定哪些日志可以提交，即根据 matchIndex 数组得到大多数 Peer 的匹配点（<code>getMajoritySameIndex</code>）？我的实现比较粗暴，复制一份，从大到小排个序，取 <code>len/2</code> 处的值。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">getMajoritySameIndex</span><span class="params">(matchIndex []<span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">  tmp := <span class="built_in">make</span>([]<span class="type">int</span>, <span class="built_in">len</span>(matchIndex))</span><br><span class="line">  <span class="built_in">copy</span>(tmp, matchIndex)</span><br><span class="line"></span><br><span class="line">  sort.Sort(sort.Reverse(sort.IntSlice(tmp)))</span><br><span class="line"></span><br><span class="line">  idx := <span class="built_in">len</span>(tmp) / <span class="number">2</span></span><br><span class="line">  <span class="keyword">return</span> tmp[idx]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>rf.applyCh</code> 不要忘记在 <code>Make</code> 函数中使用传入的参数 <code>applyCh</code> 进行赋值。</p>
</li>
<li><p>Leader&#x2F;Candidate&#x2F;Follower 在接收到比自己大的 term 的 RequestVote RPC，需要立即转为 Follower，并且重置 electionTimer。</p>
</li>
<li><p>在 Leader 收到 AppendEntries 的 Reply 时，需要先判断 term，然后再判断状态是否变了，即下面两个 if 语句顺序不能换。否则可能由于某种原因，该  Peer 状态变了（即不再是 Leader 或者 term 发生了更改），就直接返回了， 但有可能其更改后 Term 仍然比 reply.Term 小，从而没有及时变成 Follower。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> reply.Term &gt; rf.currentTerm &#123;</span><br><span class="line">  rf.becomeFollower(reply.Term)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> rf.role != LEADER || rf.currentTerm != args.Term &#123;</span><br><span class="line">  DPrintf(<span class="string">&quot;%v is not leader or changes from previous term: %v&quot;</span>, rf, args.Term)</span><br><span class="line">  <span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>每次 Leader 丢掉领导者身份后，其 <code>commitIndex</code> 需不需要回退？以及每次 Candidate 上位 Leader 时，需不需要对 <code>commitIndex = 0</code>？答案是都不需要，因为根据论文中 <strong>Leader Completeness</strong> 特性，所有被提交了日志必定会出现在后面的 Leader 的日志中。</p>
</li>
<li><p>AppendEntries 收回 reply 的时候更新 <code>rf.matchIndex 和 rf.nextIndex</code> 需要注意，不能依赖 <code>len(rf.log)</code>，因为他可能被改变，比如由于客户端请求，被追加新的日志条目了。最好用发出RPC 请求时的参数中的字段值： <code>args.PrevIndex + len(arg.Entnries)</code>，上面代码有相应注释。</p>
</li>
<li><p>TestRPCBytes2B 这个测试用例我一开始老过不了，后来发现是我心跳的时间间隔太小了，后来发现是单位写错了，将毫秒写成了微秒。从而导致对于同一个 Follower，同样的 AppendEntries 包发了太多次（稍微多发一两次测试程序是可以忍的）。</p>
</li>
<li><p>随机种子用 <code>rand.Seed(time.Now().UnixNano())</code> 好一些。</p>
</li>
<li><p>发送 AppendEntries RPC 时，当 peerID 是 Leader 自己时，也要注意更新 nextIndex 和 matchIndex：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> peerID == rf.me &#123;</span><br><span class="line">  rf.nextIndex[peerID] = <span class="built_in">len</span>(rf.log)</span><br><span class="line">  rf.matchIndex[peerID] = <span class="built_in">len</span>(rf.log) - <span class="number">1</span></span><br><span class="line">  <span class="keyword">continue</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="状态备份（Part-2C-state-persist）"><a href="#状态备份（Part-2C-state-persist）" class="headerlink" title="状态备份（Part 2C: state persist）"></a>状态备份（Part 2C: state persist）</h2><p>光从实现上来说 2C 比较简单，就是实现序列化（<code>rf.persist()</code>）和反序列化（<code>rf.readPersist()</code>）的函数，以对需要持久化的状态进行保存或者加载。并且在这些状态发生改变的时候，及时调用 <code>rf.persist()</code>。</p>
<p>但却很容易跑不过，我前年做的时候，就是卡在这了好久。因为这一个部分的测试用例更加复杂，很容易将前两个部分没实现好的点测试出来。</p>
<h3 id="序列化和反序列化"><a href="#序列化和反序列化" class="headerlink" title="序列化和反序列化"></a>序列化和反序列化</h3><p>需要持久化的状态论文中图二说的很清楚，labgob 的用法，注释中也给的很详细。需要注意的就是 rf.log 这个 Slice 不用区别对待，和普通变量一样处理即可，以序列化为例：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rf *Raft)</span></span> persist() &#123;</span><br><span class="line">  w := <span class="built_in">new</span>(bytes.Buffer)</span><br><span class="line">  e := labgob.NewEncoder(w)</span><br><span class="line">  </span><br><span class="line">  err := e.Encode(rf.currentTerm)</span><br><span class="line">  <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    DPrintf(<span class="string">&quot;%v encode currentTerm error: %v&quot;</span>, rf, err)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  err = e.Encode(rf.votedFor)</span><br><span class="line">  <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    DPrintf(<span class="string">&quot;%v encode votedFor error: %v&quot;</span>, rf, err)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  err = e.Encode(rf.log)</span><br><span class="line">  <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    DPrintf(<span class="string">&quot;%v encode log error: %v&quot;</span>, rf, err)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  data := w.Bytes()</span><br><span class="line">  rf.persister.SaveRaftState(data)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="状态改变"><a href="#状态改变" class="headerlink" title="状态改变"></a>状态改变</h3><p>代码中涉及到状态改变的主要有四个地方：</p>
<ol>
<li>发起选举，更新 term 和 votedFor 时。</li>
<li>调用 Start 追加日志，rf.log 改变时。</li>
<li>RequestVote 和 AppendEntries 两个 RPC handler 改变相关状态时。</li>
<li>Candidate&#x2F;Leader 收到 RPC 的 reply 更新自身状态时。</li>
</ol>
<p>但是测试用例 TestFigure8Unreliable2C 就是过不了。Google 一番后发现<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3NwcmluZ2ZpZWxka2luZy9taXQtNi44MjQtZ29sYWJzLTIwMTgvaXNzdWVzLzE=">别人<i class="fa fa-external-link-alt"></i></span>也有这个问题。将 pingInterval 再改小一些，拉大其与 electionTimeout 的差距可解决。最后我将参数改为如下值，该用例就过了。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> (</span><br><span class="line">  electionTimeoutMin = <span class="number">150</span></span><br><span class="line">  electionTimeoutMax = <span class="number">300</span></span><br><span class="line">  heartbeatInterval  = <span class="number">50</span> * time.Millisecond</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>但我开始将心跳间隔设置得比较大，是因为看到了材料中这么一句话：</p>
<blockquote>
<p>The paper’s Section 5.2 mentions election timeouts in the range of 150 to 300 milliseconds. Such a range only makes sense if the leader sends heartbeats considerably more often than once per 150 milliseconds. Because the tester limits you to <strong>10 heartbeats per second</strong>, you will have to use an election timeout larger than the paper’s 150 to 300 milliseconds, but not too large, because then you may fail to elect a leader within five seconds.</p>
</blockquote>
<p>但是我改成 <code>heartbeatInterval  = 50 * time.Millisecond</code>  tester 也让过了，这里我暂时有些不解。</p>
<h2 id="参考材料"><a href="#参考材料" class="headerlink" title="参考材料"></a>参考材料</h2><ol>
<li><p>Raft 论文：<span class="exturl" data-url="aHR0cHM6Ly9wZG9zLmNzYWlsLm1pdC5lZHUvNi44MjQvcGFwZXJzL3JhZnQtZXh0ZW5kZWQucGRm">https://pdos.csail.mit.edu/6.824/papers/raft-extended.pdf<i class="fa fa-external-link-alt"></i></span></p>
</li>
<li><p>Lab2 Raft 课程材料页：<span class="exturl" data-url="aHR0cHM6Ly9wZG9zLmNzYWlsLm1pdC5lZHUvNi44MjQvbGFicy9sYWItcmFmdC5odG1s">https://pdos.csail.mit.edu/6.824/labs/lab-raft.html<i class="fa fa-external-link-alt"></i></span></p>
</li>
<li><p>助教总结往年经验：<span class="exturl" data-url="aHR0cHM6Ly90aGVzcXVhcmVwbGFuZXQuY29tL2Jsb2cvc3R1ZGVudHMtZ3VpZGUtdG8tcmFmdC8lRUYlQkMlOEMlRTklQTElQkElRTQlQkUlQkYlRTglQUYlQjQlRTQlQjglODAlRTUlOTglQjQlRUYlQkMlOEMlRTglQkYlOTklRTQlQjglQUElRTUlOEElQTklRTYlOTUlOTklRTclOUElODQlRTUlOEQlOUElRTUlQUUlQTIlRTQlQjklOUYlRTYlOEMlQkElRTQlQjglOEQlRTklOTQlOTklRTMlODAlODI=">https://thesquareplanet.com/blog/students-guide-to-raft/，顺便说一嘴，这个助教的博客也挺不错。<i class="fa fa-external-link-alt"></i></span></p>
</li>
<li><p>助教 Q&amp;A：<span class="exturl" data-url="aHR0cHM6Ly90aGVzcXVhcmVwbGFuZXQuY29tL2Jsb2cvcmFmdC1xYS8=">https://thesquareplanet.com/blog/raft-qa/<i class="fa fa-external-link-alt"></i></span></p>
</li>
<li><p>Raft 用锁建议：<span class="exturl" data-url="aHR0cHM6Ly9wZG9zLmNzYWlsLm1pdC5lZHUvNi44MjQvbGFicy9yYWZ0LWxvY2tpbmcudHh0">https://pdos.csail.mit.edu/6.824/labs/raft-locking.txt<i class="fa fa-external-link-alt"></i></span></p>
</li>
<li><p>Raft 实现结构组织建议：<span class="exturl" data-url="aHR0cHM6Ly9wZG9zLmNzYWlsLm1pdC5lZHUvNi44MjQvbGFicy9yYWZ0LXN0cnVjdHVyZS50eHQ=">https://pdos.csail.mit.edu/6.824/labs/raft-structure.txt<i class="fa fa-external-link-alt"></i></span></p>
</li>
<li><p>Raft 主页，上面有个可视化动图，能帮你直观的感受下 raft，并且具有一定的交互性。此外还有更多 raft 相关的材料，也可以参考：<span class="exturl" data-url="aHR0cHM6Ly9yYWZ0LmdpdGh1Yi5pby8=">https://raft.github.io/<i class="fa fa-external-link-alt"></i></span></p>
</li>
<li><p>某个网上同学实现：<span class="exturl" data-url="aHR0cHM6Ly93aWVzZW4uZ2l0aHViLmlvL3Bvc3QvbWl0LTYuODI0LWxhYjItcmFmdC1jb25zZW5zdXMtYWxnb3JpdGhtLWltcGxlbWVudGF0aW9uLw==">https://wiesen.github.io/post/mit-6.824-lab2-raft-consensus-algorithm-implementation/<i class="fa fa-external-link-alt"></i></span></p>
</li>
</ol>
<h2 id="注解"><a href="#注解" class="headerlink" title="注解"></a>注解</h2><p>[0] Raft 中的每个 Server 文中统一称为 Peer。</p>
<p>[1] 投票者可能为 Follower，也可能为 Candidate。</p>
<p>[2]  参考论文 Figure 3 的 Log Matching 性质。</p>
<p>[3] 0 其实表示 nil，因为<code>rf.log[0]</code> 是一个无意义的空日志条目，起到<strong>哨兵</strong>的作用，可以减少一些判断，类似于链表中的 dummy Head node。</p>
<p>[4] <span class="exturl" data-url="aHR0cHM6Ly9wZG9zLmNzYWlsLm1pdC5lZHUvNi44MjQvcGFwZXJzL3JhZnQtZXh0ZW5kZWQucGRm">raft 论文<i class="fa fa-external-link-alt"></i></span> 7~8 页的引用文字有提到该策略。</p>
<p>[5] 我在实现时， votedFor 用的 int 类型，并且用的 -1 代表 null。</p>

         <HR style="border:3 double #607d8b" color=#607d8b SIZE=3>
<div>
<p>我是青藤木鸟，一个喜欢摄影、专注大规模数据系统的程序员，欢迎关注我的公众号：“<strong>木鸟杂记</strong>”，有更多的分布式系统、存储和数据库相关的文章，欢迎关注。
关注公众号后，回复“<strong>资料</strong>”可以获取我总结一份分布式数据库学习资料。
回复“<strong>优惠券</strong>”可以获取我的大规模数据系统付费专栏《<a href="https://xiaobot.net/p/system-thinking" target="_blank" rel="noopener">系统日知录</a>》的八折优惠券。</p>
<p>我们还有相关的分布式系统和数据库的群，可以添加我的微信号：qtmuniao，我拉你入群。加我时记得备注：“分布式系统群”。
另外，如果你不想加群，还有一个分布式系统和数据库的论坛（点<a target="_blank" rel="noopener" href="https://distsys.cn/">这里</a>），欢迎来玩耍。</p>
<p><img src="https://s2.loli.net/2021/12/08/Gus9ditcmZo3Ukw.jpg" alt="wx-distributed-system-s.jpg" class="medium-zoom-image"></p>
</div>
        <script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-4303078477555566"
     crossorigin="anonymous"></script>
<ins class="adsbygoogle"
     style="display:block; text-align:center;"
     data-ad-layout="in-article"
     data-ad-format="fluid"
     data-ad-client="ca-pub-4303078477555566"
     data-ad-slot="1270196241"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
    </div>

    
    
    
      
  <div class="popular-posts-header">不妨一读</div>
  <ul class="popular-posts">
    <li class="popular-posts-item">
      <div class="popular-posts-title"><a href="/2017/06/29/hadoop-0.1.0-code-debug/" rel="bookmark">Hadoop-0.1.0代码调试运行</a></div>
    </li>
    <li class="popular-posts-item">
      <div class="popular-posts-title"><a href="/2017/07/11/hadoop-source-DataNode/" rel="bookmark">Hadoop 源码阅读之DFS（二）：DataNode</a></div>
    </li>
    <li class="popular-posts-item">
      <div class="popular-posts-title"><a href="/2018/02/24/hadoop-map-reduce/" rel="bookmark">Hadoop源码阅读之MapReduce（一）：基本概念和接口</a></div>
    </li>
    <li class="popular-posts-item">
      <div class="popular-posts-title"><a href="/2017/07/02/hadoop-source-DFS/" rel="bookmark">Hadoop 源码阅读之DFS（一）：一些基本的类</a></div>
    </li>
    <li class="popular-posts-item">
      <div class="popular-posts-title"><a href="/2017/07/23/hadoop-0.1.0-file-system/" rel="bookmark">Hadoop 源码阅读之DFS（三）：FileSystem</a></div>
    </li>
    <li class="popular-posts-item">
      <div class="popular-posts-title"><a href="/2019/03/30/f4/" rel="bookmark">f4：Facebook’s Warm BLOB Storage System</a></div>
    </li>
  </ul>

        <div class="reward-container">
  <div></div>
  <button onclick="var qr = document.getElementById('qr'); qr.style.display = (qr.style.display === 'none') ? 'block' : 'none';">
    打赏
  </button>
  <div id="qr" style="display: none;">
      
      <div style="display: inline-block;">
        <img src="https://i.postimg.cc/5yGJWLQW/image.png" alt="木鸟杂记 微信支付">
        <p>微信支付</p>
      </div>

  </div>
</div>


      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/distributed-system/" rel="tag"># distributed system</a>
              <a href="/tags/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/" rel="tag"># 分布式系统</a>
              <a href="/tags/Raft/" rel="tag"># Raft</a>
              <a href="/tags/%E5%AE%9E%E7%8E%B0/" rel="tag"># 实现</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2020/01/06/go-value-pointer-method/" rel="prev" title="Golang 笔记（一）：值方法和指针方法（Value Methods vs Pointer Methods）">
      <i class="fa fa-chevron-left"></i> Golang 笔记（一）：值方法和指针方法（Value Methods vs Pointer Methods）
    </a></div>
      <div class="post-nav-item">
    <a href="/2020/01/21/mac-fix-keyboard/" rel="next" title="真香——MacBook Pro 2016 Genius Bar 更换键盘小记">
      真香——MacBook Pro 2016 Genius Bar 更换键盘小记 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          
    <div class="comments" id="gitalk-container"></div>

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%BC%95%E5%AD%90"><span class="nav-number">1.</span> <span class="nav-text">引子</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#6-824-%E4%B8%8E-Raft"><span class="nav-number">2.</span> <span class="nav-text">6.824 与 Raft</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%95%B4%E4%BD%93%E7%BB%93%E6%9E%84"><span class="nav-number">3.</span> <span class="nav-text">整体结构</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%89%E4%B8%AA%E7%8A%B6%E6%80%81"><span class="nav-number">3.1.</span> <span class="nav-text">三个状态</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%89%E4%B8%AA%E5%BE%AA%E7%8E%AF"><span class="nav-number">3.2.</span> <span class="nav-text">三个循环</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8A%A0%E9%94%81%E5%8E%9F%E5%88%99"><span class="nav-number">3.3.</span> <span class="nav-text">加锁原则</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%97%A5%E5%BF%97"><span class="nav-number">3.4.</span> <span class="nav-text">日志</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%A2%86%E5%AF%BC%E8%80%85%E9%80%89%E4%B8%BE%EF%BC%88Part-2A-leader-election%EF%BC%89"><span class="nav-number">4.</span> <span class="nav-text">领导者选举（Part 2A: leader election）</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%97%A5%E5%BF%97%E5%90%8C%E6%AD%A5%EF%BC%88Part-2B-log-replication%EF%BC%89"><span class="nav-number">5.</span> <span class="nav-text">日志同步（Part 2B: log replication）</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#matchIndex-%E5%92%8C-nextIndex"><span class="nav-number">5.1.</span> <span class="nav-text">matchIndex 和 nextIndex</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#prevLogIndex-%E5%92%8C-prevLogTerm"><span class="nav-number">5.2.</span> <span class="nav-text">prevLogIndex 和 prevLogTerm</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Leader-%E5%A4%84%E7%90%86%E5%9B%9E%E5%BA%94"><span class="nav-number">5.3.</span> <span class="nav-text">Leader 处理回应</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%80%E4%BA%9B%E7%82%B9"><span class="nav-number">5.4.</span> <span class="nav-text">一些点</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%8A%B6%E6%80%81%E5%A4%87%E4%BB%BD%EF%BC%88Part-2C-state-persist%EF%BC%89"><span class="nav-number">6.</span> <span class="nav-text">状态备份（Part 2C: state persist）</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%BA%8F%E5%88%97%E5%8C%96%E5%92%8C%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96"><span class="nav-number">6.1.</span> <span class="nav-text">序列化和反序列化</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%8A%B6%E6%80%81%E6%94%B9%E5%8F%98"><span class="nav-number">6.2.</span> <span class="nav-text">状态改变</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8F%82%E8%80%83%E6%9D%90%E6%96%99"><span class="nav-number">7.</span> <span class="nav-text">参考材料</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%B3%A8%E8%A7%A3"><span class="nav-number">8.</span> <span class="nav-text">注解</span></a></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="木鸟杂记"
      src="/img/logo.jpg">
  <p class="site-author-name" itemprop="name">木鸟杂记</p>
  <div class="site-description" itemprop="description">一个喜欢摄影的分布式程序员</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">113</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">39</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
        <span class="site-state-item-count">184</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <span class="exturl" data-url="aHR0cHM6Ly93d3cuemhpaHUuY29tL3Blb3BsZS9xdG11bmlhbw==" title="知乎 → https:&#x2F;&#x2F;www.zhihu.com&#x2F;people&#x2F;qtmuniao"><i class="zhihu fa-fw"></i>知乎</span>
      </span>
      <span class="links-of-author-item">
        <span class="exturl" data-url="aHR0cHM6Ly9zcGFjZS5iaWxpYmlsaS5jb20vMzA5MzM4MTI=" title="B站 → https:&#x2F;&#x2F;space.bilibili.com&#x2F;30933812"><i class="bzhan fa-fw"></i>B站</span>
      </span>
      <span class="links-of-author-item">
        <span class="exturl" data-url="aHR0cHM6Ly9xdG11bmlhby50dWNob25nLmNvbS8=" title="图虫 → https:&#x2F;&#x2F;qtmuniao.tuchong.com&#x2F;"><i class="tuchong fa-fw"></i>图虫</span>
      </span>
  </div>


  <div class="links-of-blogroll motion-element">
    <div class="links-of-blogroll-title"><i class="link fa-fw"></i>
      friends
    </div>
    <ul class="links-of-blogroll-list">
        <li class="links-of-blogroll-item">
          <span class="exturl" data-url="aHR0cHM6Ly9sYWlrZTltLmNvbQ==" title="https:&#x2F;&#x2F;laike9m.com">laike9m</span>
        </li>
        <li class="links-of-blogroll-item">
          <span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNoYW5na3VuLmRlLw==" title="https:&#x2F;&#x2F;blog.changkun.de&#x2F;">Changkun Ou</span>
        </li>
        <li class="links-of-blogroll-item">
          <span class="exturl" data-url="aHR0cHM6Ly93d3cua2F3YWJhbmdnYS5jb20=" title="https:&#x2F;&#x2F;www.kawabangga.com">卡瓦邦噶！</span>
        </li>
        <li class="links-of-blogroll-item">
          <span class="exturl" data-url="aHR0cHM6Ly95YW5iaW4uYmxvZw==" title="https:&#x2F;&#x2F;yanbin.blog">隔叶黄莺</span>
        </li>
        <li class="links-of-blogroll-item">
          <span class="exturl" data-url="aHR0cHM6Ly9nZWVrdHV0dS5jb20=" title="https:&#x2F;&#x2F;geektutu.com">极客兔兔</span>
        </li>
        <li class="links-of-blogroll-item">
          <span class="exturl" data-url="aHR0cHM6Ly94aWFveW91NjYuY29t" title="https:&#x2F;&#x2F;xiaoyou66.com">小游网</span>
        </li>
        <li class="links-of-blogroll-item">
          <span class="exturl" data-url="aHR0cDovL2dhb2NlZ2VnZS5jb20vQmxvZw==" title="http:&#x2F;&#x2F;gaocegege.com&#x2F;Blog">高策</span>
        </li>
        <li class="links-of-blogroll-item">
          <span class="exturl" data-url="aHR0cHM6Ly9yMTJmLmNvbQ==" title="https:&#x2F;&#x2F;r12f.com">Soul Orbit</span>
        </li>
        <li class="links-of-blogroll-item">
          <span class="exturl" data-url="aHR0cHM6Ly90YW54aW55dS53b3Jr" title="https:&#x2F;&#x2F;tanxinyu.work">谭新宇</span>
        </li>
        <li class="links-of-blogroll-item">
          <span class="exturl" data-url="aHR0cHM6Ly9penVhbHpoeS5jbi8=" title="https:&#x2F;&#x2F;izualzhy.cn&#x2F;">Ying's Blog</span>
        </li>
        <li class="links-of-blogroll-item">
          <span class="exturl" data-url="aHR0cHM6Ly9taWFuYmFvZHVvLmNvbS9vL2F1dGhvci1hV3lVbTIwPQ==" title="https:&#x2F;&#x2F;mianbaoduo.com&#x2F;o&#x2F;author-aWyUm20&#x3D;">我的面包多</span>
        </li>
        <li class="links-of-blogroll-item">
          <span class="exturl" data-url="aHR0cHM6Ly93d3cudnVsdHIuY29tLz9yZWY9ODMyOTc0OC00Rg==" title="https:&#x2F;&#x2F;www.vultr.com&#x2F;?ref&#x3D;8329748-4F">vultr vps 注册送 $50</span>
        </li>
    </ul>
  </div>


      </div>

      <div class="site-overview-wrap">
        <div class="motion-element sidebar-ads">
<script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<!-- 侧边栏-1 -->
<ins class="adsbygoogle"
style="display:inline-block;width:280px;height:100px"
data-ad-client="ca-pub-4303078477555566"
data-ad-slot="4071023010"></ins>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
</div>
<div style="
    font-size: 0.3em;
    height: 20px;
    margin-top: -10px;
">轻点广告 请我喝杯茶</div>

      </div>
        <div class="back-to-top motion-element">
          <i class="fa fa-arrow-up"></i>
          <span>0%</span>
        </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 2017 – 
  <span itemprop="copyrightYear">2024</span>
  <span class="with-love">
    <i class="user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">木鸟杂记</span>
</div>
  <div class="powered-by">由 <span class="exturl theme-link" data-url="aHR0cHM6Ly9oZXhvLmlv">Hexo</span> & <span class="exturl theme-link" data-url="aHR0cHM6Ly90aGVtZS1uZXh0Lm9yZw==">NexT.Gemini</span> 强力驱动
  </div>

        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="//cdn.jsdelivr.net/npm/medium-zoom@1/dist/medium-zoom.min.js"></script>
  <script src="//cdn.jsdelivr.net/npm/pangu@4/dist/browser/pangu.min.js"></script>

<script src="/js/utils.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  
  <script>
    (function(){
      var canonicalURL, curProtocol;
      //Get the <link> tag
      var x=document.getElementsByTagName("link");
		//Find the last canonical URL
		if(x.length > 0){
			for (i=0;i<x.length;i++){
				if(x[i].rel.toLowerCase() == 'canonical' && x[i].href){
					canonicalURL=x[i].href;
				}
			}
		}
    //Get protocol
	    if (!canonicalURL){
	    	curProtocol = window.location.protocol.split(':')[0];
	    }
	    else{
	    	curProtocol = canonicalURL.split(':')[0];
	    }
      //Get current URL if the canonical URL does not exist
	    if (!canonicalURL) canonicalURL = window.location.href;
	    //Assign script content. Replace current URL with the canonical URL
      !function(){var e=/([http|https]:\/\/[a-zA-Z0-9\_\.]+\.baidu\.com)/gi,r=canonicalURL,t=document.referrer;if(!e.test(r)){var n=(String(curProtocol).toLowerCase() === 'https')?"https://sp0.baidu.com/9_Q4simg2RQJ8t7jm9iCKT-xh_/s.gif":"//api.share.baidu.com/s.gif";t?(n+="?r="+encodeURIComponent(document.referrer),r&&(n+="&l="+r)):r&&(n+="?l="+r);var i=new Image;i.src=n}}(window);})();
  </script>















  

  
  <script src="//cdn.jsdelivr.net/npm/quicklink@1/dist/quicklink.umd.js"></script>
  <script>
      window.addEventListener('load', () => {
      quicklink({
        timeout : 3000,
        priority: true,
        ignores : [uri => uri.includes('#'),uri => uri === 'https://www.qtmuniao.com/2020/01/18/raft-implement-points/',]
      });
      });
  </script>

<link rel="stylesheet" href="//cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.css">

<script>
NexT.utils.loadComments(document.querySelector('#gitalk-container'), () => {
  NexT.utils.getScript('//cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.js', () => {
    var gitalk = new Gitalk({
      clientID    : '96b4b5363c4817dc1f62',
      clientSecret: '9e46a83f9fda0c5d3aabaaa64b60c027763cb677',
      repo        : 'blog-comment',
      owner       : 'songpengwei',
      admin       : ['songpengwei'],
      id          : '280d483c63b9f9630c3c3f6024c97c40',
        language: '',
      distractionFreeMode: true
    });
    gitalk.render('gitalk-container');
  }, window.Gitalk);
});
</script>

</body>
</html>
